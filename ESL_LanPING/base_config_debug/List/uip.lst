###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.0.51174/W32 for ARM     11/Nov/2009  14:17:09 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  E:\PROJECTs\ARM\ESL_LanPING\Sources\uip\uip.c            #
#    Command line =  E:\PROJECTs\ARM\ESL_LanPING\Sources\uip\uip.c -D         #
#                    PROTO_BORD -lC E:\PROJECTs\ARM\ESL_LanPING\base_config_d #
#                    ebug\List\ -o E:\PROJECTs\ARM\ESL_LanPING\base_config_de #
#                    bug\Obj\ --no_cse --no_unroll --no_inline                #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=ARM7TDMI   #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 5.4\arm\INC\DLib_Config_Norma #
#                    l.h" -I E:\PROJECTs\ARM\ESL_LanPING\startups\ -I         #
#                    E:\PROJECTs\ARM\ESL_LanPING\startups\at91sam7s32\ -I     #
#                    E:\PROJECTs\ARM\ESL_LanPING\Sources\ -I                  #
#                    E:\PROJECTs\ARM\ESL_LanPING\Sources\uip\ -I "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench 5.4\arm\INC\"       #
#                    --interwork --cpu_mode arm -On                           #
#    List file    =  E:\PROJECTs\ARM\ESL_LanPING\base_config_debug\List\uip.l #
#                    st                                                       #
#    Object file  =  E:\PROJECTs\ARM\ESL_LanPING\base_config_debug\Obj\uip.o  #
#                                                                             #
#                                                                             #
###############################################################################

E:\PROJECTs\ARM\ESL_LanPING\Sources\uip\uip.c
      1          #define DEBUG_PRINTF(...) /*printf(__VA_ARGS__)*/
      2          
      3          /**
      4           * \defgroup uip The uIP TCP/IP stack
      5           * @{
      6           *
      7           * uIP is an implementation of the TCP/IP protocol stack intended for
      8           * small 8-bit and 16-bit microcontrollers.
      9           *
     10           * uIP provides the necessary protocols for Internet communication,
     11           * with a very small code footprint and RAM requirements - the uIP
     12           * code size is on the order of a few kilobytes and RAM usage is on
     13           * the order of a few hundred bytes.
     14           */
     15          
     16          /**
     17           * \file
     18           * The uIP TCP/IP stack code.
     19           * \author Adam Dunkels <adam@dunkels.com>
     20           */
     21          
     22          /*
     23           * Copyright (c) 2001-2003, Adam Dunkels.
     24           * All rights reserved.
     25           *
     26           * Redistribution and use in source and binary forms, with or without
     27           * modification, are permitted provided that the following conditions
     28           * are met:
     29           * 1. Redistributions of source code must retain the above copyright
     30           *    notice, this list of conditions and the following disclaimer.
     31           * 2. Redistributions in binary form must reproduce the above copyright
     32           *    notice, this list of conditions and the following disclaimer in the
     33           *    documentation and/or other materials provided with the distribution.
     34           * 3. The name of the author may not be used to endorse or promote
     35           *    products derived from this software without specific prior
     36           *    written permission.
     37           *
     38           * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
     39           * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     40           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     41           * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
     42           * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     43           * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
     44           * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     45           * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
     46           * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     47           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     48           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     49           *
     50           * This file is part of the uIP TCP/IP stack.
     51           *
     52           * $Id: uip.c,v 1.65 2006/06/11 21:46:39 adam Exp $
     53           *
     54           */
     55          
     56          /*
     57           * uIP is a small implementation of the IP, UDP and TCP protocols (as
     58           * well as some basic ICMP stuff). The implementation couples the IP,
     59           * UDP, TCP and the application layers very tightly. To keep the size
     60           * of the compiled code down, this code frequently uses the goto
     61           * statement. While it would be possible to break the uip_process()
     62           * function into many smaller functions, this would increase the code
     63           * size because of the overhead of parameter passing and the fact that
     64           * the optimier would not be as efficient.
     65           *
     66           * The principle is that we have a small buffer, called the uip_buf,
     67           * in which the device driver puts an incoming packet. The TCP/IP
     68           * stack parses the headers in the packet, and calls the
     69           * application. If the remote host has sent data to the application,
     70           * this data is present in the uip_buf and the application read the
     71           * data from there. It is up to the application to put this data into
     72           * a byte stream if needed. The application will not be fed with data
     73           * that is out of sequence.
     74           *
     75           * If the application whishes to send data to the peer, it should put
     76           * its data into the uip_buf. The uip_appdata pointer points to the
     77           * first available byte. The TCP/IP stack will calculate the
     78           * checksums, and fill in the necessary header fields and finally send
     79           * the packet back to the peer.
     80          */
     81          
     82          #include "uip.h"
     83          #include "uipopt.h"
     84          #include "uip_arch.h"
     85          #include "uip_arp.h"
     86          
     87          #if UIP_CONF_IPV6
     88          #include "uip-neighbor.h"
     89          #endif /* UIP_CONF_IPV6 */
     90          
     91          #include <string.h>

   \                                 In section .text, align 4
   \   __??Code32?? __intrinsic __code __interwork void *memcpy(void *, void const *, size_t)
   \                     memcpy:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
   \   00000008   0150B0E1           MOVS     R5,R1
   \   0000000C   0260B0E1           MOVS     R6,R2
   \   00000010   0620B0E1           MOVS     R2,R6
   \   00000014   0510B0E1           MOVS     R1,R5
   \   00000018   0400B0E1           MOVS     R0,R4
   \   0000001C   ........           BL       __aeabi_memcpy
   \   00000020   0400B0E1           MOVS     R0,R4
   \   00000024   7040BDE8           POP      {R4-R6,LR}
   \   00000028   1EFF2FE1           BX       LR               ;; return
     92          
     93          //extern static struct arp_entry arp_table[UIP_ARPTAB_SIZE];
     94          /*---------------------------------------------------------------------------*/
     95          /* Variable definitions. */
     96          
     97          
     98          /* The IP address of this host. If it is defined to be fixed (by
     99             setting UIP_FIXEDADDR to 1 in uipopt.h), the address is set
    100             here. Otherwise, the address */
    101          #if UIP_FIXEDADDR > 0
    102          const uip_ipaddr_t uip_hostaddr =
    103            {HTONS((UIP_IPADDR0 << 8) | UIP_IPADDR1),
    104             HTONS((UIP_IPADDR2 << 8) | UIP_IPADDR3)};
    105          const uip_ipaddr_t uip_draddr =
    106            {HTONS((UIP_DRIPADDR0 << 8) | UIP_DRIPADDR1),
    107             HTONS((UIP_DRIPADDR2 << 8) | UIP_DRIPADDR3)};
    108          const uip_ipaddr_t uip_netmask =
    109            {HTONS((UIP_NETMASK0 << 8) | UIP_NETMASK1),
    110             HTONS((UIP_NETMASK2 << 8) | UIP_NETMASK3)};
    111          #else

   \                                 In section .bss, align 4
    112          uip_ipaddr_t uip_hostaddr, uip_draddr, uip_netmask;
   \                     uip_hostaddr:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     uip_draddr:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     uip_netmask:
   \   00000000                      DS8 4
    113          #endif /* UIP_FIXEDADDR */
    114          
    115          //static const uip_ipaddr_t all_ones_addr =
    116          //#if UIP_CONF_IPV6
    117          //  {0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff,0xffff};
    118          //#else /* UIP_CONF_IPV6 */
    119          //  {0xffff,0xffff};
    120          //#endif /* UIP_CONF_IPV6 */

   \                                 In section .rodata, align 4
    121          static const uip_ipaddr_t all_zeroes_addr =
   \                     all_zeroes_addr:
   \   00000000   00000000           DC16 0, 0
    122          #if UIP_CONF_IPV6
    123            {0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000};
    124          #else /* UIP_CONF_IPV6 */
    125            {0x0000,0x0000};
    126          #endif /* UIP_CONF_IPV6 */
    127          
    128          #if UIP_FIXEDETHADDR
    129          const struct uip_eth_addr uip_ethaddr = {{UIP_ETHADDR0,
    130          					  UIP_ETHADDR1,
    131          					  UIP_ETHADDR2,
    132          					  UIP_ETHADDR3,
    133          					  UIP_ETHADDR4,
    134          					  UIP_ETHADDR5}};
    135          #else

   \                                 In section .bss, align 4
    136          struct uip_eth_addr uip_ethaddr = {{0,0,0,0,0,0}};
   \                     uip_ethaddr:
   \   00000000                      DS8 8
    137          #endif
    138          
    139          #ifndef UIP_CONF_EXTERNAL_BUFFER
    140          
    141          #ifdef __ICCARM__
    142          	#pragma data_alignment=4

   \                                 In section .bss, align 4
    143          		u8_t uip_buf[UIP_BUFSIZE + 2]; /* The packet buffer that contains incoming packets. */
   \                     uip_buf:
   \   00000000                      DS8 1504
    144          #else
    145          	u8_t uip_buf[UIP_BUFSIZE + 2] ALIGN_STRUCT_END; /* The packet buffer that contains incoming packets. */
    146          #endif
    147          				
    148          #endif /* UIP_CONF_EXTERNAL_BUFFER */
    149          

   \                                 In section .bss, align 4
    150          void *uip_appdata;               /* The uip_appdata pointer points to
   \                     uip_appdata:
   \   00000000                      DS8 4
    151          				    application data. */

   \                                 In section .bss, align 4
    152          void *uip_sappdata;              /* The uip_appdata pointer points to
   \                     uip_sappdata:
   \   00000000                      DS8 4
    153          				    the application data which is to
    154          				    be sent. */
    155          #if UIP_URGDATA > 0
    156          void *uip_urgdata;               /* The uip_urgdata pointer points to
    157             				    urgent data (out-of-band data), if
    158             				    present. */
    159          u16_t uip_urglen, uip_surglen;
    160          #endif /* UIP_URGDATA > 0 */
    161          

   \                                 In section .bss, align 2
    162          u16_t uip_len, uip_slen;
   \                     uip_len:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
   \                     uip_slen:
   \   00000000                      DS8 2
    163                                       /* The uip_len is either 8 or 16 bits,
    164          				depending on the maximum packet
    165          				size. */
    166          

   \                                 In section .bss, align 1
    167          u8_t uip_flags;     /* The uip_flags variable is used for
   \                     uip_flags:
   \   00000000                      DS8 1
    168          				communication between the TCP/IP stack
    169          				and the application program. */

   \                                 In section .bss, align 4
    170          struct uip_conn *uip_conn;   /* uip_conn always points to the current
   \                     uip_conn:
   \   00000000                      DS8 4
    171          				connection. */
    172          

   \                                 In section .bss, align 4
    173          struct uip_conn uip_conns[UIP_CONNS];
   \                     uip_conns:
   \   00000000                      DS8 168
    174                                       /* The uip_conns array holds all TCP
    175          				connections. */

   \                                 In section .bss, align 2
    176          u16_t uip_listenports[UIP_LISTENPORTS];
   \                     uip_listenports:
   \   00000000                      DS8 2
    177                                       /* The uip_listenports list all currently
    178          				listning ports. */

   \                                 In section .bss, align 1
    179          char ping_flag  = 0;
   \                     ping_flag:
   \   00000000                      DS8 1
    180          
    181          #if UIP_UDP
    182          struct uip_udp_conn *uip_udp_conn;
    183          struct uip_udp_conn uip_udp_conns[UIP_UDP_CONNS];
    184          #endif /* UIP_UDP */
    185          

   \                                 In section .bss, align 2
    186          static u16_t ipid;           /* Ths ipid variable is an increasing
   \                     ipid:
   \   00000000                      DS8 2
    187          				number that is used for the IP ID
    188          				field. */
    189          

   \                                 In section .text, align 4, keep-with-next
    190          void uip_setipid(u16_t id) { ipid = id; }
   \                     uip_setipid:
   \   00000000   ........           LDR      R1,??DataTable0  ;; ipid
   \   00000004   B000C1E1           STRH     R0,[R1, #+0]
   \   00000008   1EFF2FE1           BX       LR               ;; return
    191          

   \                                 In section .bss, align 4
    192          static u8_t iss[4];          /* The iss variable is used for the TCP
   \                     iss:
   \   00000000                      DS8 4
    193          				initial sequence number. */
    194          
    195          #if UIP_ACTIVE_OPEN
    196          static u16_t lastport;       /* Keeps track of the last port used for
    197          				a new connection. */
    198          #endif /* UIP_ACTIVE_OPEN */
    199          
    200          /* Temporary variables. */

   \                                 In section .bss, align 4
    201          u8_t uip_acc32[4];
   \                     uip_acc32:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
    202          static u8_t c, opt;
   \                     c:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     opt:
   \   00000000                      DS8 1

   \                                 In section .bss, align 2
    203          static u16_t tmp16;
   \                     tmp16:
   \   00000000                      DS8 2
    204          
    205          /* Structures and definitions. */
    206          #define TCP_FIN 0x01
    207          #define TCP_SYN 0x02
    208          #define TCP_RST 0x04
    209          #define TCP_PSH 0x08
    210          #define TCP_ACK 0x10
    211          #define TCP_URG 0x20
    212          #define TCP_CTL 0x3f
    213          
    214          #define TCP_OPT_END     0   /* End of TCP options list */
    215          #define TCP_OPT_NOOP    1   /* "No-operation" TCP option */
    216          #define TCP_OPT_MSS     2   /* Maximum segment size TCP option */
    217          
    218          #define TCP_OPT_MSS_LEN 4   /* Length of TCP MSS option. */
    219          
    220          #define ICMP_ECHO_REPLY 0
    221          #define ICMP_ECHO       8
    222          
    223          #define ICMP6_ECHO_REPLY             129
    224          #define ICMP6_ECHO                   128
    225          #define ICMP6_NEIGHBOR_SOLICITATION  135
    226          #define ICMP6_NEIGHBOR_ADVERTISEMENT 136
    227          
    228          #define ICMP6_FLAG_S (1 << 6)
    229          
    230          #define ICMP6_OPTION_SOURCE_LINK_ADDRESS 1
    231          #define ICMP6_OPTION_TARGET_LINK_ADDRESS 2
    232          
    233          
    234          /* Macros. */
    235          #define BUF ((struct uip_tcpip_hdr *)&uip_buf[UIP_LLH_LEN])
    236          //#define FBUF ((struct uip_tcpip_hdr *)&uip_reassbuf[0])
    237          #define ICMPBUF ((struct uip_icmpip_hdr *)&uip_buf[UIP_LLH_LEN])
    238          //#define UDPBUF ((struct uip_udpip_hdr *)&uip_buf[UIP_LLH_LEN])
    239          
    240          //extern unsigned char s_uip_send;
    241          
    242          #if UIP_STATISTICS == 1
    243          struct uip_stats uip_stat;
    244          #define UIP_STAT(s) s
    245          #else
    246          #define UIP_STAT(s)
    247          #endif /* UIP_STATISTICS == 1 */
    248          
    249          #if UIP_LOGGING == 1
    250          #include <stdio.h>
    251          void uip_log(char *msg);
    252          #define UIP_LOG(m) uip_log(m)
    253          #else
    254          #define UIP_LOG(m)
    255          #endif /* UIP_LOGGING == 1 */
    256          
    257          #if ! UIP_ARCH_ADD32

   \                                 In section .text, align 4, keep-with-next
    258          void
    259          uip_add32(u8_t *op32, u16_t op16)
    260          {
    261            uip_acc32[3] = op32[3] + (op16 & 0xff);
   \                     uip_add32:
   \   00000000   0320D0E5           LDRB     R2,[R0, #+3]
   \   00000004   0130B0E1           MOVS     R3,R1
   \   00000008   022093E0           ADDS     R2,R3,R2
   \   0000000C   ........           LDR      R3,??DataTable61  ;; uip_acc32 + 3
   \   00000010   0020C3E5           STRB     R2,[R3, #+0]
    262            uip_acc32[2] = op32[2] + (op16 >> 8);
   \   00000014   0220D0E5           LDRB     R2,[R0, #+2]
   \   00000018   212492E0           ADDS     R2,R2,R1, LSR #+8
   \   0000001C   ........           LDR      R3,??DataTable59  ;; uip_acc32 + 2
   \   00000020   0020C3E5           STRB     R2,[R3, #+0]
    263            uip_acc32[1] = op32[1];
   \   00000024   ........           LDR      R2,??DataTable57  ;; uip_acc32 + 1
   \   00000028   0130D0E5           LDRB     R3,[R0, #+1]
   \   0000002C   0030C2E5           STRB     R3,[R2, #+0]
    264            uip_acc32[0] = op32[0];
   \   00000030   ........           LDR      R2,??DataTable55  ;; uip_acc32
   \   00000034   0030D0E5           LDRB     R3,[R0, #+0]
   \   00000038   0030C2E5           STRB     R3,[R2, #+0]
    265          
    266            if(uip_acc32[2] < (op16 >> 8)) {
   \   0000003C   ........           LDR      R2,??DataTable59  ;; uip_acc32 + 2
   \   00000040   0020D2E5           LDRB     R2,[R2, #+0]
   \   00000044   2134B0E1           LSRS     R3,R1,#+8
   \   00000048   FF3013E2           ANDS     R3,R3,#0xFF      ;; Zero extend
   \   0000004C   030052E1           CMP      R2,R3
   \   00000050   0D00002A           BCS      ??uip_add32_0
    267              ++uip_acc32[1];
   \   00000054   ........           LDR      R2,??DataTable57  ;; uip_acc32 + 1
   \   00000058   0020D2E5           LDRB     R2,[R2, #+0]
   \   0000005C   012092E2           ADDS     R2,R2,#+1
   \   00000060   ........           LDR      R3,??DataTable57  ;; uip_acc32 + 1
   \   00000064   0020C3E5           STRB     R2,[R3, #+0]
    268              if(uip_acc32[1] == 0) {
   \   00000068   ........           LDR      R2,??DataTable57  ;; uip_acc32 + 1
   \   0000006C   0020D2E5           LDRB     R2,[R2, #+0]
   \   00000070   000052E3           CMP      R2,#+0
   \   00000074   0400001A           BNE      ??uip_add32_1
    269                ++uip_acc32[0];
   \   00000078   ........           LDR      R2,??DataTable55  ;; uip_acc32
   \   0000007C   0020D2E5           LDRB     R2,[R2, #+0]
   \   00000080   012092E2           ADDS     R2,R2,#+1
   \   00000084   ........           LDR      R3,??DataTable55  ;; uip_acc32
   \   00000088   0020C3E5           STRB     R2,[R3, #+0]
    270              }
    271            }
    272          
    273          
    274            if(uip_acc32[3] < (op16 & 0xff)) {
   \                     ??uip_add32_1:
   \                     ??uip_add32_0:
   \   0000008C   ........           LDR      R2,??DataTable61  ;; uip_acc32 + 3
   \   00000090   0020D2E5           LDRB     R2,[R2, #+0]
   \   00000094   0130B0E1           MOVS     R3,R1
   \   00000098   0338A0E1           MOV      R3,R3, LSL #+16
   \   0000009C   2338B0E1           MOVS     R3,R3, LSR #+16
   \   000000A0   FF3013E2           ANDS     R3,R3,#0xFF
   \   000000A4   030052E1           CMP      R2,R3
   \   000000A8   160000AA           BGE      ??uip_add32_2
    275              ++uip_acc32[2];
   \   000000AC   ........           LDR      R2,??DataTable59  ;; uip_acc32 + 2
   \   000000B0   0020D2E5           LDRB     R2,[R2, #+0]
   \   000000B4   012092E2           ADDS     R2,R2,#+1
   \   000000B8   ........           LDR      R3,??DataTable59  ;; uip_acc32 + 2
   \   000000BC   0020C3E5           STRB     R2,[R3, #+0]
    276              if(uip_acc32[2] == 0) {
   \   000000C0   ........           LDR      R2,??DataTable59  ;; uip_acc32 + 2
   \   000000C4   0020D2E5           LDRB     R2,[R2, #+0]
   \   000000C8   000052E3           CMP      R2,#+0
   \   000000CC   0D00001A           BNE      ??uip_add32_3
    277                ++uip_acc32[1];
   \   000000D0   ........           LDR      R2,??DataTable57  ;; uip_acc32 + 1
   \   000000D4   0020D2E5           LDRB     R2,[R2, #+0]
   \   000000D8   012092E2           ADDS     R2,R2,#+1
   \   000000DC   ........           LDR      R3,??DataTable57  ;; uip_acc32 + 1
   \   000000E0   0020C3E5           STRB     R2,[R3, #+0]
    278                if(uip_acc32[1] == 0) {
   \   000000E4   ........           LDR      R2,??DataTable57  ;; uip_acc32 + 1
   \   000000E8   0020D2E5           LDRB     R2,[R2, #+0]
   \   000000EC   000052E3           CMP      R2,#+0
   \   000000F0   0400001A           BNE      ??uip_add32_4
    279          	++uip_acc32[0];
   \   000000F4   ........           LDR      R2,??DataTable55  ;; uip_acc32
   \   000000F8   0020D2E5           LDRB     R2,[R2, #+0]
   \   000000FC   012092E2           ADDS     R2,R2,#+1
   \   00000100   ........           LDR      R3,??DataTable55  ;; uip_acc32
   \   00000104   0020C3E5           STRB     R2,[R3, #+0]
    280                }
    281              }
    282            }
    283          }
   \                     ??uip_add32_4:
   \                     ??uip_add32_3:
   \                     ??uip_add32_2:
   \   00000108   1EFF2FE1           BX       LR               ;; return
    284          
    285          #endif /* UIP_ARCH_ADD32 */
    286          
    287          #if ! UIP_ARCH_CHKSUM
    288          /*---------------------------------------------------------------------------*/

   \                                 In section .text, align 4, keep-with-next
    289          static u16_t
    290          chksum(u16_t sum, const u8_t *data, u16_t len)
    291          {
   \                     chksum:
   \   00000000   38402DE9           PUSH     {R3-R5,LR}
    292            u16_t t;
    293            const u8_t *dataptr;
    294            const u8_t *last_byte;
    295          
    296            dataptr = data;
   \   00000004   01C0B0E1           MOVS     R12,R1
    297            last_byte = data + len - 1;
   \   00000008   0240B0E1           MOVS     R4,R2
   \   0000000C   0448A0E1           MOV      R4,R4, LSL #+16
   \   00000010   2448B0E1           MOVS     R4,R4, LSR #+16
   \   00000014   014094E0           ADDS     R4,R4,R1
   \   00000018   014054E2           SUBS     R4,R4,#+1
   \   0000001C   04E0B0E1           MOVS     LR,R4
    298          
    299            while(dataptr < last_byte) {	/* At least two more bytes */
   \                     ??chksum_0:
   \   00000020   0E005CE1           CMP      R12,LR
   \   00000024   0D00002A           BCS      ??chksum_1
    300              t = (dataptr[0] << 8) + dataptr[1];
   \   00000028   0040DCE5           LDRB     R4,[R12, #+0]
   \   0000002C   0150DCE5           LDRB     R5,[R12, #+1]
   \   00000030   044495E0           ADDS     R4,R5,R4, LSL #+8
   \   00000034   0430B0E1           MOVS     R3,R4
    301              sum += t;
   \   00000038   000093E0           ADDS     R0,R3,R0
    302              if(sum < t) {
   \   0000003C   0008A0E1           MOV      R0,R0, LSL #+16
   \   00000040   2008B0E1           MOVS     R0,R0, LSR #+16
   \   00000044   0338A0E1           MOV      R3,R3, LSL #+16
   \   00000048   2338B0E1           MOVS     R3,R3, LSR #+16
   \   0000004C   030050E1           CMP      R0,R3
   \   00000050   0000002A           BCS      ??chksum_2
    303                sum++;		/* carry */
   \   00000054   010090E2           ADDS     R0,R0,#+1
    304              }
    305              dataptr += 2;
   \                     ??chksum_2:
   \   00000058   02C09CE2           ADDS     R12,R12,#+2
   \   0000005C   EFFFFFEA           B        ??chksum_0
    306            }
    307          
    308            if(dataptr == last_byte) {
   \                     ??chksum_1:
   \   00000060   0E005CE1           CMP      R12,LR
   \   00000064   0A00001A           BNE      ??chksum_3
    309              t = (dataptr[0] << 8) + 0;
   \   00000068   0040DCE5           LDRB     R4,[R12, #+0]
   \   0000006C   0444B0E1           LSLS     R4,R4,#+8
   \   00000070   0430B0E1           MOVS     R3,R4
    310              sum += t;
   \   00000074   000093E0           ADDS     R0,R3,R0
    311              if(sum < t) {
   \   00000078   0008A0E1           MOV      R0,R0, LSL #+16
   \   0000007C   2008B0E1           MOVS     R0,R0, LSR #+16
   \   00000080   0338A0E1           MOV      R3,R3, LSL #+16
   \   00000084   2338B0E1           MOVS     R3,R3, LSR #+16
   \   00000088   030050E1           CMP      R0,R3
   \   0000008C   0000002A           BCS      ??chksum_4
    312                sum++;		/* carry */
   \   00000090   010090E2           ADDS     R0,R0,#+1
    313              }
    314            }
    315          
    316            /* Return sum in host byte order. */
    317            return sum;
   \                     ??chksum_4:
   \                     ??chksum_3:
   \   00000094   0008A0E1           MOV      R0,R0, LSL #+16
   \   00000098   2008B0E1           MOVS     R0,R0, LSR #+16
   \   0000009C   3240BDE8           POP      {R1,R4,R5,LR}
   \   000000A0   1EFF2FE1           BX       LR               ;; return
    318          }
    319          /*---------------------------------------------------------------------------*/

   \                                 In section .text, align 4, keep-with-next
    320          u16_t
    321          uip_chksum(u16_t *data, u16_t len)
    322          {
   \                     uip_chksum:
   \   00000000   38402DE9           PUSH     {R3-R5,LR}
   \   00000004   0050B0E1           MOVS     R5,R0
   \   00000008   0140B0E1           MOVS     R4,R1
    323            return htons(chksum(0, (u8_t *)data, len));
   \   0000000C   0420B0E1           MOVS     R2,R4
   \   00000010   0228A0E1           MOV      R2,R2, LSL #+16
   \   00000014   2228B0E1           MOVS     R2,R2, LSR #+16
   \   00000018   0510B0E1           MOVS     R1,R5
   \   0000001C   0000A0E3           MOV      R0,#+0
   \   00000020   ........           BL       chksum
   \   00000024   0008A0E1           MOV      R0,R0, LSL #+16
   \   00000028   2008B0E1           MOVS     R0,R0, LSR #+16
   \   0000002C   ........           BL       htons
   \   00000030   3240BDE8           POP      {R1,R4,R5,LR}
   \   00000034   1EFF2FE1           BX       LR               ;; return
    324          }
    325          /*---------------------------------------------------------------------------*/
    326          #ifndef UIP_ARCH_IPCHKSUM

   \                                 In section .text, align 4, keep-with-next
    327          u16_t
    328          uip_ipchksum(void)
    329          {
   \                     uip_ipchksum:
   \   00000000   10402DE9           PUSH     {R4,LR}
    330            u16_t sum;
    331          
    332            sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
   \   00000004   1420A0E3           MOV      R2,#+20
   \   00000008   ........           LDR      R1,??DataTable20  ;; uip_buf + 14
   \   0000000C   0000A0E3           MOV      R0,#+0
   \   00000010   ........           BL       chksum
   \   00000014   0040B0E1           MOVS     R4,R0
    333            DEBUG_PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
    334            return (sum == 0) ? 0xffff : htons(sum);
   \   00000018   0448A0E1           MOV      R4,R4, LSL #+16
   \   0000001C   2448B0E1           MOVS     R4,R4, LSR #+16
   \   00000020   000054E3           CMP      R4,#+0
   \   00000024   0200001A           BNE      ??uip_ipchksum_0
   \   00000028   FF00A0E3           MOV      R0,#+255
   \   0000002C   FF0C80E3           ORR      R0,R0,#0xFF00
   \   00000030   030000EA           B        ??uip_ipchksum_1
   \                     ??uip_ipchksum_0:
   \   00000034   0400B0E1           MOVS     R0,R4
   \   00000038   0008A0E1           MOV      R0,R0, LSL #+16
   \   0000003C   2008B0E1           MOVS     R0,R0, LSR #+16
   \   00000040   ........           BL       htons
   \                     ??uip_ipchksum_1:
   \   00000044   0008A0E1           MOV      R0,R0, LSL #+16
   \   00000048   2008B0E1           MOVS     R0,R0, LSR #+16
   \   0000004C   1040BDE8           POP      {R4,LR}
   \   00000050   1EFF2FE1           BX       LR               ;; return
    335          }
    336          #endif
    337          /*---------------------------------------------------------------------------*/

   \                                 In section .text, align 4, keep-with-next
    338          static u16_t
    339          upper_layer_chksum(u8_t proto)
    340          {
   \                     upper_layer_chksum:
   \   00000000   70402DE9           PUSH     {R4-R6,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
    341            u16_t upper_layer_len;
    342            u16_t sum;
    343          
    344          //#if UIP_CONF_IPV6
    345          //  upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]);
    346          //#else /* UIP_CONF_IPV6 */
    347            upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]) - UIP_IPH_LEN;
   \   00000008   ........           LDR      R0,??DataTable21  ;; uip_buf + 16
   \   0000000C   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000010   ........           LDR      R1,??DataTable22  ;; uip_buf + 17
   \   00000014   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000018   000491E0           ADDS     R0,R1,R0, LSL #+8
   \   0000001C   140050E2           SUBS     R0,R0,#+20
   \   00000020   0050B0E1           MOVS     R5,R0
    348          //#endif /* UIP_CONF_IPV6 */
    349          
    350            /* First sum pseudoheader. */
    351          
    352            /* IP protocol and length fields. This addition cannot carry. */
    353            sum = upper_layer_len + proto;
   \   00000024   0400B0E1           MOVS     R0,R4
   \   00000028   FF0010E2           ANDS     R0,R0,#0xFF      ;; Zero extend
   \   0000002C   050090E0           ADDS     R0,R0,R5
   \   00000030   0060B0E1           MOVS     R6,R0
    354            /* Sum IP source and destination addresses. */
    355            sum = chksum(sum, (u8_t *)&BUF->srcipaddr[0], 2 * sizeof(uip_ipaddr_t));
   \   00000034   0820A0E3           MOV      R2,#+8
   \   00000038   ........           LDR      R1,??DataTable23  ;; uip_buf + 26
   \   0000003C   0600B0E1           MOVS     R0,R6
   \   00000040   0008A0E1           MOV      R0,R0, LSL #+16
   \   00000044   2008B0E1           MOVS     R0,R0, LSR #+16
   \   00000048   ........           BL       chksum
   \   0000004C   0060B0E1           MOVS     R6,R0
    356          
    357            /* Sum TCP header and data. */
    358            sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
    359          	       upper_layer_len);
   \   00000050   0520B0E1           MOVS     R2,R5
   \   00000054   0228A0E1           MOV      R2,R2, LSL #+16
   \   00000058   2228B0E1           MOVS     R2,R2, LSR #+16
   \   0000005C   ........           LDR      R1,??DataTable24  ;; uip_buf + 34
   \   00000060   0600B0E1           MOVS     R0,R6
   \   00000064   0008A0E1           MOV      R0,R0, LSL #+16
   \   00000068   2008B0E1           MOVS     R0,R0, LSR #+16
   \   0000006C   ........           BL       chksum
   \   00000070   0060B0E1           MOVS     R6,R0
    360          
    361            return (sum == 0) ? 0xffff : htons(sum);
   \   00000074   0668A0E1           MOV      R6,R6, LSL #+16
   \   00000078   2668B0E1           MOVS     R6,R6, LSR #+16
   \   0000007C   000056E3           CMP      R6,#+0
   \   00000080   0200001A           BNE      ??upper_layer_chksum_0
   \   00000084   FF00A0E3           MOV      R0,#+255
   \   00000088   FF0C80E3           ORR      R0,R0,#0xFF00
   \   0000008C   030000EA           B        ??upper_layer_chksum_1
   \                     ??upper_layer_chksum_0:
   \   00000090   0600B0E1           MOVS     R0,R6
   \   00000094   0008A0E1           MOV      R0,R0, LSL #+16
   \   00000098   2008B0E1           MOVS     R0,R0, LSR #+16
   \   0000009C   ........           BL       htons
   \                     ??upper_layer_chksum_1:
   \   000000A0   0008A0E1           MOV      R0,R0, LSL #+16
   \   000000A4   2008B0E1           MOVS     R0,R0, LSR #+16
   \   000000A8   7040BDE8           POP      {R4-R6,LR}
   \   000000AC   1EFF2FE1           BX       LR               ;; return
    362          }
    363          /*---------------------------------------------------------------------------*/
    364          //#if UIP_CONF_IPV6
    365          //u16_t
    366          //uip_icmp6chksum(void)
    367          //{
    368          //  return upper_layer_chksum(UIP_PROTO_ICMP6);
    369          //
    370          //}
    371          //#endif /* UIP_CONF_IPV6 */
    372          /*---------------------------------------------------------------------------*/

   \                                 In section .text, align 4, keep-with-next
    373          u16_t
    374          uip_tcpchksum(void)
    375          {
   \                     uip_tcpchksum:
   \   00000000   00502DE9           PUSH     {R12,LR}
    376            return upper_layer_chksum(UIP_PROTO_TCP);
   \   00000004   0600A0E3           MOV      R0,#+6
   \   00000008   ........           BL       upper_layer_chksum
   \   0000000C   0240BDE8           POP      {R1,LR}
   \   00000010   1EFF2FE1           BX       LR               ;; return
    377          }
    378          /*---------------------------------------------------------------------------*/
    379          #if UIP_UDP_CHECKSUMS
    380          u16_t
    381          uip_udpchksum(void)
    382          {
    383            return upper_layer_chksum(UIP_PROTO_UDP);
    384          }
    385          #endif /* UIP_UDP_CHECKSUMS */
    386          #endif /* UIP_ARCH_CHKSUM */
    387          /*---------------------------------------------------------------------------*/

   \                                 In section .text, align 4, keep-with-next
    388          void
    389          uip_init(void)
    390          {
    391            for(c = 0; c < UIP_LISTENPORTS; ++c) {
   \                     uip_init:
   \   00000000   ........           LDR      R0,??DataTable52  ;; c
   \   00000004   0010A0E3           MOV      R1,#+0
   \   00000008   0010C0E5           STRB     R1,[R0, #+0]
   \                     ??uip_init_0:
   \   0000000C   ........           LDR      R0,??DataTable52  ;; c
   \   00000010   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000014   010050E3           CMP      R0,#+1
   \   00000018   0C00002A           BCS      ??uip_init_1
    392              uip_listenports[c] = 0;
   \   0000001C   ........           LDR      R0,??DataTable52  ;; c
   \   00000020   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000024   0210A0E3           MOV      R1,#+2
   \   00000028   ........           LDR      R2,??DataTable50  ;; uip_listenports
   \   0000002C   912020E0           MLA      R0,R1,R0,R2
   \   00000030   0010A0E3           MOV      R1,#+0
   \   00000034   B010C0E1           STRH     R1,[R0, #+0]
    393            }
   \   00000038   ........           LDR      R0,??DataTable52  ;; c
   \   0000003C   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000040   010090E2           ADDS     R0,R0,#+1
   \   00000044   ........           LDR      R1,??DataTable52  ;; c
   \   00000048   0000C1E5           STRB     R0,[R1, #+0]
   \   0000004C   EEFFFFEA           B        ??uip_init_0
    394            for(c = 0; c < UIP_CONNS; ++c) {
   \                     ??uip_init_1:
   \   00000050   ........           LDR      R0,??DataTable52  ;; c
   \   00000054   0010A0E3           MOV      R1,#+0
   \   00000058   0010C0E5           STRB     R1,[R0, #+0]
   \                     ??uip_init_2:
   \   0000005C   ........           LDR      R0,??DataTable52  ;; c
   \   00000060   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000064   010050E3           CMP      R0,#+1
   \   00000068   0C00002A           BCS      ??uip_init_3
    395              uip_conns[c].tcpstateflags = UIP_CLOSED;
   \   0000006C   ........           LDR      R0,??DataTable52  ;; c
   \   00000070   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000074   A810A0E3           MOV      R1,#+168
   \   00000078   ........           LDR      R2,??DataTable34  ;; uip_conns
   \   0000007C   912020E0           MLA      R0,R1,R0,R2
   \   00000080   0010A0E3           MOV      R1,#+0
   \   00000084   1910C0E5           STRB     R1,[R0, #+25]
    396            }
   \   00000088   ........           LDR      R0,??DataTable52  ;; c
   \   0000008C   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000090   010090E2           ADDS     R0,R0,#+1
   \   00000094   ........           LDR      R1,??DataTable52  ;; c
   \   00000098   0000C1E5           STRB     R0,[R1, #+0]
   \   0000009C   EEFFFFEA           B        ??uip_init_2
    397          #if UIP_ACTIVE_OPEN
    398            lastport = 1024;
    399          #endif /* UIP_ACTIVE_OPEN */
    400          
    401          #if UIP_UDP
    402            for(c = 0; c < UIP_UDP_CONNS; ++c) {
    403              uip_udp_conns[c].lport = 0;
    404            }
    405          #endif /* UIP_UDP */
    406          
    407          
    408            /* IPv4 initialization. */
    409          #if UIP_FIXEDADDR == 0
    410            /*  uip_hostaddr[0] = uip_hostaddr[1] = 0;*/
    411          #endif /* UIP_FIXEDADDR */
    412          
    413          }
   \                     ??uip_init_3:
   \   000000A0   1EFF2FE1           BX       LR               ;; return
    414          /*---------------------------------------------------------------------------*/
    415          #if UIP_ACTIVE_OPEN
    416          struct uip_conn *
    417          uip_connect(uip_ipaddr_t *ripaddr, u16_t rport)
    418          {
    419            register struct uip_conn *conn, *cconn;
    420          
    421            /* Find an unused local port. */
    422           again:
    423            ++lastport;
    424          
    425            if(lastport >= 32000) {
    426              lastport = 4096;
    427            }
    428          
    429            /* Check if this port is already in use, and if so try to find
    430               another one. */
    431            for(c = 0; c < UIP_CONNS; ++c) {
    432              conn = &uip_conns[c];
    433              if(conn->tcpstateflags != UIP_CLOSED &&
    434                 conn->lport == htons(lastport)) {
    435                goto again;
    436              }
    437            }
    438          
    439            conn = 0;
    440            for(c = 0; c < UIP_CONNS; ++c) {
    441              cconn = &uip_conns[c];
    442              if(cconn->tcpstateflags == UIP_CLOSED) {
    443                conn = cconn;
    444                break;
    445              }
    446              if(cconn->tcpstateflags == UIP_TIME_WAIT) {
    447                if(conn == 0 ||
    448          	 cconn->timer > conn->timer) {
    449          	conn = cconn;
    450                }
    451              }
    452            }
    453          
    454            if(conn == 0) {
    455              return 0;
    456            }
    457          
    458            conn->tcpstateflags = UIP_SYN_SENT;
    459          
    460            conn->snd_nxt[0] = iss[0];
    461            conn->snd_nxt[1] = iss[1];
    462            conn->snd_nxt[2] = iss[2];
    463            conn->snd_nxt[3] = iss[3];
    464          
    465            conn->initialmss = conn->mss = UIP_TCP_MSS;
    466          
    467            conn->len = 1;   /* TCP length of the SYN is one. */
    468            conn->nrtx = 0;
    469            conn->timer = 1; /* Send the SYN next time around. */
    470            conn->rto = UIP_RTO;
    471            conn->sa = 0;
    472            conn->sv = 16;   /* Initial value of the RTT variance. */
    473            conn->lport = htons(lastport);
    474            conn->rport = rport;
    475            uip_ipaddr_copy(&conn->ripaddr, ripaddr);
    476          
    477            return conn;
    478          }
    479          #endif /* UIP_ACTIVE_OPEN */
    480          /*---------------------------------------------------------------------------*/
    481          #if UIP_UDP
    482          struct uip_udp_conn *
    483          uip_udp_new(uip_ipaddr_t *ripaddr, u16_t rport)
    484          {
    485            register struct uip_udp_conn *conn;
    486          
    487            /* Find an unused local port. */
    488           again:
    489            ++lastport;
    490          
    491            if(lastport >= 32000) {
    492              lastport = 4096;
    493            }
    494          
    495            for(c = 0; c < UIP_UDP_CONNS; ++c) {
    496              if(uip_udp_conns[c].lport == htons(lastport)) {
    497                goto again;
    498              }
    499            }
    500          
    501          
    502            conn = 0;
    503            for(c = 0; c < UIP_UDP_CONNS; ++c) {
    504              if(uip_udp_conns[c].lport == 0) {
    505                conn = &uip_udp_conns[c];
    506                break;
    507              }
    508            }
    509          
    510            if(conn == 0) {
    511              return 0;
    512            }
    513          
    514            conn->lport = HTONS(lastport);
    515            conn->rport = rport;
    516            if(ripaddr == NULL) {
    517              memset(conn->ripaddr, 0, sizeof(uip_ipaddr_t));
    518            } else {
    519              uip_ipaddr_copy(&conn->ripaddr, ripaddr);
    520            }
    521            conn->ttl = UIP_TTL;
    522          
    523            return conn;
    524          }
    525          #endif /* UIP_UDP */
    526          /*---------------------------------------------------------------------------*/

   \                                 In section .text, align 4, keep-with-next
    527          void
    528          uip_unlisten(u16_t port)
    529          {
    530            for(c = 0; c < UIP_LISTENPORTS; ++c) {
   \                     uip_unlisten:
   \   00000000   ........           LDR      R1,??DataTable52  ;; c
   \   00000004   0020A0E3           MOV      R2,#+0
   \   00000008   0020C1E5           STRB     R2,[R1, #+0]
   \                     ??uip_unlisten_0:
   \   0000000C   ........           LDR      R1,??DataTable52  ;; c
   \   00000010   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000014   010051E3           CMP      R1,#+1
   \   00000018   1700002A           BCS      ??uip_unlisten_1
    531              if(uip_listenports[c] == port) {
   \   0000001C   ........           LDR      R1,??DataTable52  ;; c
   \   00000020   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000024   0220A0E3           MOV      R2,#+2
   \   00000028   ........           LDR      R3,??DataTable50  ;; uip_listenports
   \   0000002C   923121E0           MLA      R1,R2,R1,R3
   \   00000030   B010D1E1           LDRH     R1,[R1, #+0]
   \   00000034   0008A0E1           MOV      R0,R0, LSL #+16
   \   00000038   2008B0E1           MOVS     R0,R0, LSR #+16
   \   0000003C   000051E1           CMP      R1,R0
   \   00000040   0700001A           BNE      ??uip_unlisten_2
    532                uip_listenports[c] = 0;
   \   00000044   ........           LDR      R1,??DataTable52  ;; c
   \   00000048   0010D1E5           LDRB     R1,[R1, #+0]
   \   0000004C   0220A0E3           MOV      R2,#+2
   \   00000050   ........           LDR      R3,??DataTable50  ;; uip_listenports
   \   00000054   923121E0           MLA      R1,R2,R1,R3
   \   00000058   0020A0E3           MOV      R2,#+0
   \   0000005C   B020C1E1           STRH     R2,[R1, #+0]
    533                return;
   \   00000060   050000EA           B        ??uip_unlisten_3
    534              }
    535            }
   \                     ??uip_unlisten_2:
   \   00000064   ........           LDR      R1,??DataTable52  ;; c
   \   00000068   0010D1E5           LDRB     R1,[R1, #+0]
   \   0000006C   011091E2           ADDS     R1,R1,#+1
   \   00000070   ........           LDR      R2,??DataTable52  ;; c
   \   00000074   0010C2E5           STRB     R1,[R2, #+0]
   \   00000078   E3FFFFEA           B        ??uip_unlisten_0
    536          }
   \                     ??uip_unlisten_1:
   \                     ??uip_unlisten_3:
   \   0000007C   1EFF2FE1           BX       LR               ;; return
    537          /*---------------------------------------------------------------------------*/

   \                                 In section .text, align 4, keep-with-next
    538          void
    539          uip_listen(u16_t port)
    540          {
    541            for(c = 0; c < UIP_LISTENPORTS; ++c) {
   \                     uip_listen:
   \   00000000   ........           LDR      R1,??DataTable52  ;; c
   \   00000004   0020A0E3           MOV      R2,#+0
   \   00000008   0020C1E5           STRB     R2,[R1, #+0]
   \                     ??uip_listen_0:
   \   0000000C   ........           LDR      R1,??DataTable52  ;; c
   \   00000010   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000014   010051E3           CMP      R1,#+1
   \   00000018   1400002A           BCS      ??uip_listen_1
    542              if(uip_listenports[c] == 0) {
   \   0000001C   ........           LDR      R1,??DataTable52  ;; c
   \   00000020   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000024   0220A0E3           MOV      R2,#+2
   \   00000028   ........           LDR      R3,??DataTable50  ;; uip_listenports
   \   0000002C   923121E0           MLA      R1,R2,R1,R3
   \   00000030   B010D1E1           LDRH     R1,[R1, #+0]
   \   00000034   000051E3           CMP      R1,#+0
   \   00000038   0600001A           BNE      ??uip_listen_2
    543                uip_listenports[c] = port;
   \   0000003C   ........           LDR      R1,??DataTable52  ;; c
   \   00000040   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000044   0220A0E3           MOV      R2,#+2
   \   00000048   ........           LDR      R3,??DataTable50  ;; uip_listenports
   \   0000004C   923121E0           MLA      R1,R2,R1,R3
   \   00000050   B000C1E1           STRH     R0,[R1, #+0]
    544                return;
   \   00000054   050000EA           B        ??uip_listen_3
    545              }
    546            }
   \                     ??uip_listen_2:
   \   00000058   ........           LDR      R1,??DataTable52  ;; c
   \   0000005C   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000060   011091E2           ADDS     R1,R1,#+1
   \   00000064   ........           LDR      R2,??DataTable52  ;; c
   \   00000068   0010C2E5           STRB     R1,[R2, #+0]
   \   0000006C   E6FFFFEA           B        ??uip_listen_0
    547          }
   \                     ??uip_listen_1:
   \                     ??uip_listen_3:
   \   00000070   1EFF2FE1           BX       LR               ;; return
    548          /*---------------------------------------------------------------------------*/
    549          /* XXX: IP fragment reassembly: not well-tested. */
    550          
    551          #if UIP_REASSEMBLY && !UIP_CONF_IPV6
    552          #define UIP_REASS_BUFSIZE (UIP_BUFSIZE - UIP_LLH_LEN)
    553          static u8_t uip_reassbuf[UIP_REASS_BUFSIZE];
    554          static u8_t uip_reassbitmap[UIP_REASS_BUFSIZE / (8 * 8)];
    555          static const u8_t bitmap_bits[8] = {0xff, 0x7f, 0x3f, 0x1f,
    556          				    0x0f, 0x07, 0x03, 0x01};
    557          static u16_t uip_reasslen;
    558          static u8_t uip_reassflags;
    559          #define UIP_REASS_FLAG_LASTFRAG 0x01
    560          static u8_t uip_reasstmr;
    561          
    562          #define IP_MF   0x20
    563          
    564          static u8_t
    565          uip_reass(void)
    566          {
    567            u16_t offset, len;
    568            u16_t i;
    569          
    570            /* If ip_reasstmr is zero, no packet is present in the buffer, so we
    571               write the IP header of the fragment into the reassembly
    572               buffer. The timer is updated with the maximum age. */
    573            if(uip_reasstmr == 0) {
    574              memcpy(uip_reassbuf, &BUF->vhl, UIP_IPH_LEN);
    575              uip_reasstmr = UIP_REASS_MAXAGE;
    576              uip_reassflags = 0;
    577              /* Clear the bitmap. */
    578              memset(uip_reassbitmap, 0, sizeof(uip_reassbitmap));
    579            }
    580          
    581            /* Check if the incoming fragment matches the one currently present
    582               in the reasembly buffer. If so, we proceed with copying the
    583               fragment into the buffer. */
    584            if(BUF->srcipaddr[0] == FBUF->srcipaddr[0] &&
    585               BUF->srcipaddr[1] == FBUF->srcipaddr[1] &&
    586               BUF->destipaddr[0] == FBUF->destipaddr[0] &&
    587               BUF->destipaddr[1] == FBUF->destipaddr[1] &&
    588               BUF->ipid[0] == FBUF->ipid[0] &&
    589               BUF->ipid[1] == FBUF->ipid[1]) {
    590          
    591              len = (BUF->len[0] << 8) + BUF->len[1] - (BUF->vhl & 0x0f) * 4;
    592              offset = (((BUF->ipoffset[0] & 0x3f) << 8) + BUF->ipoffset[1]) * 8;
    593          
    594              /* If the offset or the offset + fragment length overflows the
    595                 reassembly buffer, we discard the entire packet. */
    596              if(offset > UIP_REASS_BUFSIZE ||
    597                 offset + len > UIP_REASS_BUFSIZE) {
    598                uip_reasstmr = 0;
    599                goto nullreturn;
    600              }
    601          
    602              /* Copy the fragment into the reassembly buffer, at the right
    603                 offset. */
    604              memcpy(&uip_reassbuf[UIP_IPH_LEN + offset],
    605          	   (char *)BUF + (int)((BUF->vhl & 0x0f) * 4),
    606          	   len);
    607          
    608              /* Update the bitmap. */
    609              if(offset / (8 * 8) == (offset + len) / (8 * 8)) {
    610                /* If the two endpoints are in the same byte, we only update
    611          	 that byte. */
    612          	
    613                uip_reassbitmap[offset / (8 * 8)] |=
    614          	     bitmap_bits[(offset / 8 ) & 7] &
    615          	     ~bitmap_bits[((offset + len) / 8 ) & 7];
    616              } else {
    617                /* If the two endpoints are in different bytes, we update the
    618          	 bytes in the endpoints and fill the stuff inbetween with
    619          	 0xff. */
    620                uip_reassbitmap[offset / (8 * 8)] |=
    621          	bitmap_bits[(offset / 8 ) & 7];
    622                for(i = 1 + offset / (8 * 8); i < (offset + len) / (8 * 8); ++i) {
    623          	uip_reassbitmap[i] = 0xff;
    624                }
    625                uip_reassbitmap[(offset + len) / (8 * 8)] |=
    626          	~bitmap_bits[((offset + len) / 8 ) & 7];
    627              }
    628          
    629              /* If this fragment has the More Fragments flag set to zero, we
    630                 know that this is the last fragment, so we can calculate the
    631                 size of the entire packet. We also set the
    632                 IP_REASS_FLAG_LASTFRAG flag to indicate that we have received
    633                 the final fragment. */
    634          
    635              if((BUF->ipoffset[0] & IP_MF) == 0) {
    636                uip_reassflags |= UIP_REASS_FLAG_LASTFRAG;
    637                uip_reasslen = offset + len;
    638              }
    639          
    640              /* Finally, we check if we have a full packet in the buffer. We do
    641                 this by checking if we have the last fragment and if all bits
    642                 in the bitmap are set. */
    643              if(uip_reassflags & UIP_REASS_FLAG_LASTFRAG) {
    644                /* Check all bytes up to and including all but the last byte in
    645          	 the bitmap. */
    646                for(i = 0; i < uip_reasslen / (8 * 8) - 1; ++i) {
    647          	if(uip_reassbitmap[i] != 0xff) {
    648          	  goto nullreturn;
    649          	}
    650                }
    651                /* Check the last byte in the bitmap. It should contain just the
    652          	 right amount of bits. */
    653                if(uip_reassbitmap[uip_reasslen / (8 * 8)] !=
    654          	 (u8_t)~bitmap_bits[uip_reasslen / 8 & 7]) {
    655          	goto nullreturn;
    656                }
    657          
    658                /* If we have come this far, we have a full packet in the
    659          	 buffer, so we allocate a pbuf and copy the packet into it. We
    660          	 also reset the timer. */
    661                uip_reasstmr = 0;
    662                memcpy(BUF, FBUF, uip_reasslen);
    663          
    664                /* Pretend to be a "normal" (i.e., not fragmented) IP packet
    665          	 from now on. */
    666                BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
    667                BUF->len[0] = uip_reasslen >> 8;
    668                BUF->len[1] = uip_reasslen & 0xff;
    669                
    670                BUF->ipchksum = 0;
    671                BUF->ipchksum = ~(uip_ipchksum());
    672          
    673                return uip_reasslen;
    674              }
    675            }
    676          
    677           nullreturn:
    678            return 0;
    679          }
    680          #endif /* UIP_REASSEMBLY */
    681          /*---------------------------------------------------------------------------*/

   \                                 In section .text, align 4, keep-with-next
    682          static void
    683          uip_add_rcv_nxt(u16_t n)
    684          {
   \                     uip_add_rcv_nxt:
   \   00000000   10402DE9           PUSH     {R4,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
    685            uip_add32(uip_conn->rcv_nxt, n);
   \   00000008   0410B0E1           MOVS     R1,R4
   \   0000000C   0118A0E1           MOV      R1,R1, LSL #+16
   \   00000010   2118B0E1           MOVS     R1,R1, LSR #+16
   \   00000014   ........           LDR      R0,??DataTable60  ;; uip_conn
   \   00000018   000090E5           LDR      R0,[R0, #+0]
   \   0000001C   080090E2           ADDS     R0,R0,#+8
   \   00000020   ........           BL       uip_add32
    686            uip_conn->rcv_nxt[0] = uip_acc32[0];
   \   00000024   ........           LDR      R0,??DataTable60  ;; uip_conn
   \   00000028   000090E5           LDR      R0,[R0, #+0]
   \   0000002C   ........           LDR      R1,??DataTable55  ;; uip_acc32
   \   00000030   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000034   0810C0E5           STRB     R1,[R0, #+8]
    687            uip_conn->rcv_nxt[1] = uip_acc32[1];
   \   00000038   ........           LDR      R0,??DataTable60  ;; uip_conn
   \   0000003C   000090E5           LDR      R0,[R0, #+0]
   \   00000040   ........           LDR      R1,??DataTable57  ;; uip_acc32 + 1
   \   00000044   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000048   0910C0E5           STRB     R1,[R0, #+9]
    688            uip_conn->rcv_nxt[2] = uip_acc32[2];
   \   0000004C   ........           LDR      R0,??DataTable60  ;; uip_conn
   \   00000050   000090E5           LDR      R0,[R0, #+0]
   \   00000054   ........           LDR      R1,??DataTable59  ;; uip_acc32 + 2
   \   00000058   0010D1E5           LDRB     R1,[R1, #+0]
   \   0000005C   0A10C0E5           STRB     R1,[R0, #+10]
    689            uip_conn->rcv_nxt[3] = uip_acc32[3];
   \   00000060   ........           LDR      R0,??DataTable60  ;; uip_conn
   \   00000064   000090E5           LDR      R0,[R0, #+0]
   \   00000068   ........           LDR      R1,??DataTable61  ;; uip_acc32 + 3
   \   0000006C   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000070   0B10C0E5           STRB     R1,[R0, #+11]
    690          }
   \   00000074   1040BDE8           POP      {R4,LR}
   \   00000078   1EFF2FE1           BX       LR               ;; return
    691          /*---------------------------------------------------------------------------*/

   \                                 In section .text, align 4, keep-with-next
    692          void
    693          uip_process(u8_t flag)
    694          {
   \                     uip_process:
   \   00000000   38402DE9           PUSH     {R3-R5,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
    695            register struct uip_conn *uip_connr = uip_conn;
   \   00000008   AC0E9FE5           LDR      R0,??uip_process_2  ;; uip_conn
   \   0000000C   000090E5           LDR      R0,[R0, #+0]
   \   00000010   0050B0E1           MOVS     R5,R0
    696          //
    697          //#if UIP_UDP
    698          //  if(flag == UIP_UDP_SEND_CONN) {
    699          //    goto udp_send;
    700          //  }
    701          //#endif /* UIP_UDP */
    702          
    703            uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
   \   00000014   A40E9FE5           LDR      R0,??uip_process_2+0x4  ;; uip_buf + 54
   \   00000018   A41E9FE5           LDR      R1,??uip_process_2+0x8  ;; uip_appdata
   \   0000001C   000081E5           STR      R0,[R1, #+0]
   \   00000020   A01E9FE5           LDR      R1,??uip_process_2+0xC  ;; uip_sappdata
   \   00000024   000081E5           STR      R0,[R1, #+0]
    704          
    705            /* Check if we were invoked because of a poll request for a
    706               particular connection. */
    707            if(flag == UIP_POLL_REQUEST) {
   \   00000028   FF4014E2           ANDS     R4,R4,#0xFF      ;; Zero extend
   \   0000002C   030054E3           CMP      R4,#+3
   \   00000030   0C00001A           BNE      ??uip_process_3
    708              if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED &&
    709                 !uip_outstanding(uip_connr)) {
   \   00000034   1900D5E5           LDRB     R0,[R5, #+25]
   \   00000038   0F0010E2           ANDS     R0,R0,#0xF
   \   0000003C   030050E3           CMP      R0,#+3
   \   00000040   0700001A           BNE      ??uip_process_4
   \   00000044   B001D5E1           LDRH     R0,[R5, #+16]
   \   00000048   000050E3           CMP      R0,#+0
   \   0000004C   0400001A           BNE      ??uip_process_4
    710          	uip_flags = UIP_POLL;
   \   00000050   740E9FE5           LDR      R0,??uip_process_2+0x10  ;; uip_flags
   \   00000054   0810A0E3           MOV      R1,#+8
   \   00000058   0010C0E5           STRB     R1,[R0, #+0]
    711          	UIP_APPCALL();
   \   0000005C   ........           BL       telnetd_appcall
    712          	goto appsend;
   \   00000060   FB0300EA           B        ??uip_process_5
    713              }
    714              goto drop;
   \                     ??uip_process_4:
   \   00000064   350500EA           B        ??uip_process_6
    715          
    716              /* Check if we were invoked because of the perodic timer fireing. */
    717            } else if(flag == UIP_TIMER)
   \                     ??uip_process_3:
   \   00000068   FF4014E2           ANDS     R4,R4,#0xFF      ;; Zero extend
   \   0000006C   020054E3           CMP      R4,#+2
   \   00000070   7C00001A           BNE      ??uip_process_7
    718            {
    719          //#if UIP_REASSEMBLY
    720          //    if(uip_reasstmr != 0) {
    721          //      --uip_reasstmr;
    722          //    }
    723          //#endif /* UIP_REASSEMBLY */
    724              /* Increase the initial sequence number. */
    725              if(++iss[3] == 0) {
   \   00000074   540E9FE5           LDR      R0,??uip_process_2+0x14  ;; iss + 3
   \   00000078   0000D0E5           LDRB     R0,[R0, #+0]
   \   0000007C   010090E2           ADDS     R0,R0,#+1
   \   00000080   481E9FE5           LDR      R1,??uip_process_2+0x14  ;; iss + 3
   \   00000084   0000C1E5           STRB     R0,[R1, #+0]
   \   00000088   FF0010E2           ANDS     R0,R0,#0xFF      ;; Zero extend
   \   0000008C   000050E3           CMP      R0,#+0
   \   00000090   1400001A           BNE      ??uip_process_8
    726                if(++iss[2] == 0) {
   \   00000094   380E9FE5           LDR      R0,??uip_process_2+0x18  ;; iss + 2
   \   00000098   0000D0E5           LDRB     R0,[R0, #+0]
   \   0000009C   010090E2           ADDS     R0,R0,#+1
   \   000000A0   2C1E9FE5           LDR      R1,??uip_process_2+0x18  ;; iss + 2
   \   000000A4   0000C1E5           STRB     R0,[R1, #+0]
   \   000000A8   FF0010E2           ANDS     R0,R0,#0xFF      ;; Zero extend
   \   000000AC   000050E3           CMP      R0,#+0
   \   000000B0   0C00001A           BNE      ??uip_process_9
    727          	if(++iss[1] == 0) {
   \   000000B4   1C0E9FE5           LDR      R0,??uip_process_2+0x1C  ;; iss + 1
   \   000000B8   0000D0E5           LDRB     R0,[R0, #+0]
   \   000000BC   010090E2           ADDS     R0,R0,#+1
   \   000000C0   101E9FE5           LDR      R1,??uip_process_2+0x1C  ;; iss + 1
   \   000000C4   0000C1E5           STRB     R0,[R1, #+0]
   \   000000C8   FF0010E2           ANDS     R0,R0,#0xFF      ;; Zero extend
   \   000000CC   000050E3           CMP      R0,#+0
   \   000000D0   0400001A           BNE      ??uip_process_10
    728          	  ++iss[0];
   \   000000D4   000E9FE5           LDR      R0,??uip_process_2+0x20  ;; iss
   \   000000D8   0000D0E5           LDRB     R0,[R0, #+0]
   \   000000DC   010090E2           ADDS     R0,R0,#+1
   \   000000E0   F41D9FE5           LDR      R1,??uip_process_2+0x20  ;; iss
   \   000000E4   0000C1E5           STRB     R0,[R1, #+0]
    729          	}
    730                }
    731              }
    732          
    733              /* Reset the length variables. */
    734              uip_len = 0;
   \                     ??uip_process_10:
   \                     ??uip_process_9:
   \                     ??uip_process_8:
   \   000000E8   F00D9FE5           LDR      R0,??uip_process_2+0x24  ;; uip_len
   \   000000EC   0010A0E3           MOV      R1,#+0
   \   000000F0   B010C0E1           STRH     R1,[R0, #+0]
    735              uip_slen = 0;
   \   000000F4   E80D9FE5           LDR      R0,??uip_process_2+0x28  ;; uip_slen
   \   000000F8   0010A0E3           MOV      R1,#+0
   \   000000FC   B010C0E1           STRH     R1,[R0, #+0]
    736          
    737              /* Check if the connection is in a state in which we simply wait
    738                 for the connection to time out. If so, we increase the
    739                 connection's timer and remove the connection if it times
    740                 out. */
    741              if(uip_connr->tcpstateflags == UIP_TIME_WAIT ||
    742                 uip_connr->tcpstateflags == UIP_FIN_WAIT_2) {
   \   00000100   1900D5E5           LDRB     R0,[R5, #+25]
   \   00000104   070050E3           CMP      R0,#+7
   \   00000108   0200000A           BEQ      ??uip_process_11
   \   0000010C   1900D5E5           LDRB     R0,[R5, #+25]
   \   00000110   050050E3           CMP      R0,#+5
   \   00000114   0800001A           BNE      ??uip_process_12
    743                ++(uip_connr->timer);
   \                     ??uip_process_11:
   \   00000118   1A00D5E5           LDRB     R0,[R5, #+26]
   \   0000011C   010090E2           ADDS     R0,R0,#+1
   \   00000120   1A00C5E5           STRB     R0,[R5, #+26]
    744                if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
   \   00000124   1A00D5E5           LDRB     R0,[R5, #+26]
   \   00000128   780050E3           CMP      R0,#+120
   \   0000012C   0100001A           BNE      ??uip_process_13
    745          	uip_connr->tcpstateflags = UIP_CLOSED;
   \   00000130   0000A0E3           MOV      R0,#+0
   \   00000134   1900C5E5           STRB     R0,[R5, #+25]
   \                     ??uip_process_13:
   \   00000138   490000EA           B        ??uip_process_14
    746                }
    747              } else if(uip_connr->tcpstateflags != UIP_CLOSED) {
   \                     ??uip_process_12:
   \   0000013C   1900D5E5           LDRB     R0,[R5, #+25]
   \   00000140   000050E3           CMP      R0,#+0
   \   00000144   4600000A           BEQ      ??uip_process_15
    748                /* If the connection has outstanding data, we increase the
    749          	 connection's timer and see if it has reached the RTO value
    750          	 in which case we retransmit. */
    751                if(uip_outstanding(uip_connr)) {
   \   00000148   B001D5E1           LDRH     R0,[R5, #+16]
   \   0000014C   000050E3           CMP      R0,#+0
   \   00000150   3A00000A           BEQ      ??uip_process_16
    752          	  uip_connr->timer = uip_connr->timer - 1;
   \   00000154   1A00D5E5           LDRB     R0,[R5, #+26]
   \   00000158   010050E2           SUBS     R0,R0,#+1
   \   0000015C   1A00C5E5           STRB     R0,[R5, #+26]
    753          	if(uip_connr->timer == 0) {
   \   00000160   1A00D5E5           LDRB     R0,[R5, #+26]
   \   00000164   000050E3           CMP      R0,#+0
   \   00000168   3300001A           BNE      ??uip_process_17
    754          	  if(uip_connr->nrtx == UIP_MAXRTX ||
    755          	     ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
    756          	       uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
    757          	      uip_connr->nrtx == UIP_MAXSYNRTX)) {
   \   0000016C   1B00D5E5           LDRB     R0,[R5, #+27]
   \   00000170   080050E3           CMP      R0,#+8
   \   00000174   0800000A           BEQ      ??uip_process_18
   \   00000178   1900D5E5           LDRB     R0,[R5, #+25]
   \   0000017C   020050E3           CMP      R0,#+2
   \   00000180   0200000A           BEQ      ??uip_process_19
   \   00000184   1900D5E5           LDRB     R0,[R5, #+25]
   \   00000188   010050E3           CMP      R0,#+1
   \   0000018C   0C00001A           BNE      ??uip_process_20
   \                     ??uip_process_19:
   \   00000190   1B00D5E5           LDRB     R0,[R5, #+27]
   \   00000194   050050E3           CMP      R0,#+5
   \   00000198   0900001A           BNE      ??uip_process_20
    758          	    uip_connr->tcpstateflags = UIP_CLOSED;
   \                     ??uip_process_18:
   \   0000019C   0000A0E3           MOV      R0,#+0
   \   000001A0   1900C5E5           STRB     R0,[R5, #+25]
    759          
    760          	    /* We call UIP_APPCALL() with uip_flags set to
    761          	       UIP_TIMEDOUT to inform the application that the
    762          	       connection has timed out. */
    763          	    uip_flags = UIP_TIMEDOUT;
   \   000001A4   200D9FE5           LDR      R0,??uip_process_2+0x10  ;; uip_flags
   \   000001A8   8010A0E3           MOV      R1,#+128
   \   000001AC   0010C0E5           STRB     R1,[R0, #+0]
    764          	    UIP_APPCALL();
   \   000001B0   ........           BL       telnetd_appcall
    765          
    766          	    /* We also send a reset packet to the remote host. */
    767          	    BUF->flags = TCP_RST | TCP_ACK;
   \   000001B4   2C0D9FE5           LDR      R0,??uip_process_2+0x2C  ;; uip_buf + 47
   \   000001B8   1410A0E3           MOV      R1,#+20
   \   000001BC   0010C0E5           STRB     R1,[R0, #+0]
    768          	    goto tcp_send_nodata;
   \   000001C0   5E0400EA           B        ??uip_process_21
    769          	  }
    770          
    771          	  /* Exponential backoff. */
    772          	  uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4?
    773          					 4:
    774          					 uip_connr->nrtx);
   \                     ??uip_process_20:
   \   000001C4   1B00D5E5           LDRB     R0,[R5, #+27]
   \   000001C8   050050E3           CMP      R0,#+5
   \   000001CC   0100003A           BCC      ??uip_process_22
   \   000001D0   0400A0E3           MOV      R0,#+4
   \   000001D4   000000EA           B        ??uip_process_23
   \                     ??uip_process_22:
   \   000001D8   1B00D5E5           LDRB     R0,[R5, #+27]
   \                     ??uip_process_23:
   \   000001DC   0310A0E3           MOV      R1,#+3
   \   000001E0   1100B0E1           LSLS     R0,R1,R0
   \   000001E4   1A00C5E5           STRB     R0,[R5, #+26]
    775          	  ++(uip_connr->nrtx);
   \   000001E8   1B00D5E5           LDRB     R0,[R5, #+27]
   \   000001EC   010090E2           ADDS     R0,R0,#+1
   \   000001F0   1B00C5E5           STRB     R0,[R5, #+27]
    776          	
    777          	  /* Ok, so we need to retransmit. We do this differently
    778          	     depending on which state we are in. In ESTABLISHED, we
    779          	     call upon the application so that it may prepare the
    780          	     data for the retransmit. In SYN_RCVD, we resend the
    781          	     SYNACK that we sent earlier and in LAST_ACK we have to
    782          	     retransmit our FINACK. */
    783          	  UIP_STAT(++uip_stat.tcp.rexmit);
    784          	  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
   \   000001F4   1900D5E5           LDRB     R0,[R5, #+25]
   \   000001F8   0F0010E2           ANDS     R0,R0,#0xF
   \   000001FC   FF0010E2           ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000200   010040E2           SUB      R0,R0,#+1
   \   00000204   070050E3           CMP      R0,#+7
   \   00000208   0B00008A           BHI      ??uip_process_24
   \   0000020C   04108FE2           ADR      R1,??uip_process_0
   \   00000210   0010D1E7           LDRB     R1,[R1, R0]
   \   00000214   01F18FE0           ADD      PC,PC,R1, LSL #+2
   \                     ??uip_process_0:
   \   00000218   01080207           DC8      +1,+8,+2,+7
   \   0000021C   08070807           DC8      +8,+7,+8,+7
    785          	  case UIP_SYN_RCVD:
    786          	    /* In the SYN_RCVD state, we should retransmit our
    787                         SYNACK. */
    788          	    goto tcp_send_synack;
   \                     ??uip_process_25:
   \   00000220   2B0200EA           B        ??uip_process_26
    789          	
    790          #if UIP_ACTIVE_OPEN
    791          	  case UIP_SYN_SENT:
    792          	    /* In the SYN_SENT state, we retransmit out SYN. */
    793          	    BUF->flags = 0;
    794          	    goto tcp_send_syn;
    795          #endif /* UIP_ACTIVE_OPEN */
    796          	
    797          	  case UIP_ESTABLISHED:
    798          	    /* In the ESTABLISHED state, we call upon the application
    799                         to do the actual retransmit after which we jump into
    800                         the code for sending out the packet (the apprexmit
    801                         label). */
    802          	    uip_flags = UIP_REXMIT;
   \                     ??uip_process_27:
   \   00000224   A00C9FE5           LDR      R0,??uip_process_2+0x10  ;; uip_flags
   \   00000228   0410A0E3           MOV      R1,#+4
   \   0000022C   0010C0E5           STRB     R1,[R0, #+0]
    803          	    UIP_APPCALL();
   \   00000230   ........           BL       telnetd_appcall
    804          	    goto apprexmit;
   \   00000234   C20300EA           B        ??uip_process_28
    805          	
    806          	  case UIP_FIN_WAIT_1:
    807          	  case UIP_CLOSING:
    808          	  case UIP_LAST_ACK:
    809          	    /* In all these states we should retransmit a FINACK. */
    810          	    goto tcp_send_finack;
   \                     ??uip_process_29:
   \   00000238   1B0300EA           B        ??uip_process_30
    811          	
    812          	  }
    813          	}
    814                } else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED) {
   \                     ??uip_process_24:
   \                     ??uip_process_17:
   \   0000023C   080000EA           B        ??uip_process_31
   \                     ??uip_process_16:
   \   00000240   1900D5E5           LDRB     R0,[R5, #+25]
   \   00000244   0F0010E2           ANDS     R0,R0,#0xF
   \   00000248   030050E3           CMP      R0,#+3
   \   0000024C   0400001A           BNE      ??uip_process_32
    815          	/* If there was no need for a retransmission, we poll the
    816                     application for new data. */
    817          	uip_flags = UIP_POLL;
   \   00000250   740C9FE5           LDR      R0,??uip_process_2+0x10  ;; uip_flags
   \   00000254   0810A0E3           MOV      R1,#+8
   \   00000258   0010C0E5           STRB     R1,[R0, #+0]
    818          	UIP_APPCALL();
   \   0000025C   ........           BL       telnetd_appcall
    819          	goto appsend;
   \   00000260   7B0300EA           B        ??uip_process_5
    820                }
    821              }
    822              goto drop;
   \                     ??uip_process_32:
   \                     ??uip_process_31:
   \                     ??uip_process_15:
   \                     ??uip_process_14:
   \   00000264   B50400EA           B        ??uip_process_6
    823            }
    824          //#if UIP_UDP
    825          //  if(flag == UIP_UDP_TIMER) {
    826          //    if(uip_udp_conn->lport != 0) {
    827          //      uip_conn = NULL;
    828          //      uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
    829          //      uip_len = uip_slen = 0;
    830          //      uip_flags = UIP_POLL;
    831          //      UIP_UDP_APPCALL();
    832          //      goto udp_send;
    833          //    } else {
    834          //      goto drop;
    835          //    }
    836          //  }
    837          //#endif
    838          
    839            /* This is where the input processing starts. */
    840            UIP_STAT(++uip_stat.ip.recv);
    841          
    842            /* Start of IP input header processing code. */
    843          
    844          //#if UIP_CONF_IPV6
    845          //  /* Check validity of the IP header. */
    846          //  if((BUF->vtc & 0xf0) != 0x60)  { /* IP version and header length. */
    847          //    UIP_STAT(++uip_stat.ip.drop);
    848          //    UIP_STAT(++uip_stat.ip.vhlerr);
    849          //    UIP_LOG("ipv6: invalid version.");
    850          //    goto drop;
    851          //  }
    852          //#else /* UIP_CONF_IPV6 */
    853            /* Check validity of the IP header. */
    854            if(BUF->vhl != 0x45)  { /* IP version and header length. */
   \                     ??uip_process_7:
   \   00000268   7C0C9FE5           LDR      R0,??uip_process_2+0x30  ;; uip_buf + 14
   \   0000026C   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000270   450050E3           CMP      R0,#+69
   \   00000274   B104001A           BNE      ??uip_process_6
    855              UIP_STAT(++uip_stat.ip.drop);
    856              UIP_STAT(++uip_stat.ip.vhlerr);
    857              UIP_LOG("ip: invalid version or header length.");
    858              goto drop;
    859            }
    860          //#endif /* UIP_CONF_IPV6 */
    861          
    862            /* Check the size of the packet. If the size reported to us in
    863               uip_len is smaller the size reported in the IP header, we assume
    864               that the packet has been corrupted in transit. If the size of
    865               uip_len is larger than the size reported in the IP packet header,
    866               the packet has been padded and we set uip_len to the correct
    867               value.. */
    868          
    869            if((BUF->len[0] << 8) + BUF->len[1] <= uip_len) {
   \                     ??uip_process_33:
   \   00000278   600C9FE5           LDR      R0,??uip_process_2+0x24  ;; uip_len
   \   0000027C   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000280   681C9FE5           LDR      R1,??uip_process_2+0x34  ;; uip_buf + 16
   \   00000284   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000288   642C9FE5           LDR      R2,??uip_process_2+0x38  ;; uip_buf + 17
   \   0000028C   0020D2E5           LDRB     R2,[R2, #+0]
   \   00000290   011492E0           ADDS     R1,R2,R1, LSL #+8
   \   00000294   010050E1           CMP      R0,R1
   \   00000298   0B0000BA           BLT      ??uip_process_34
    870              uip_len = (BUF->len[0] << 8) + BUF->len[1];
   \   0000029C   4C0C9FE5           LDR      R0,??uip_process_2+0x34  ;; uip_buf + 16
   \   000002A0   0000D0E5           LDRB     R0,[R0, #+0]
   \   000002A4   481C9FE5           LDR      R1,??uip_process_2+0x38  ;; uip_buf + 17
   \   000002A8   0010D1E5           LDRB     R1,[R1, #+0]
   \   000002AC   000491E0           ADDS     R0,R1,R0, LSL #+8
   \   000002B0   281C9FE5           LDR      R1,??uip_process_2+0x24  ;; uip_len
   \   000002B4   B000C1E1           STRH     R0,[R1, #+0]
    871          //#if UIP_CONF_IPV6
    872          //    uip_len += 40; /* The length reported in the IPv6 header is the
    873          //		      length of the payload that follows the
    874          //		      header. However, uIP uses the uip_len variable
    875          //		      for holding the size of the entire packet,
    876          //		      including the IP header. For IPv4 this is not a
    877          //		      problem as the length field in the IPv4 header
    878          //		      contains the length of the entire packet. But
    879          //		      for IPv6 we need to add the size of the IPv6
    880          //		      header (40 bytes). */
    881          //#endif /* UIP_CONF_IPV6 */
    882            } else {
    883              UIP_LOG("ip: packet shorter than reported in IP header.");
    884              goto drop;
    885            }
    886          
    887          #if !UIP_CONF_IPV6
    888            /* Check the fragment flag. */
    889            if((BUF->ipoffset[0] & 0x3f) != 0 ||
    890               BUF->ipoffset[1] != 0) {
   \   000002B8   380C9FE5           LDR      R0,??uip_process_2+0x3C  ;; uip_buf + 20
   \   000002BC   0000D0E5           LDRB     R0,[R0, #+0]
   \   000002C0   3F0010E3           TST      R0,#0x3F
   \   000002C4   0500001A           BNE      ??uip_process_35
   \   000002C8   000000EA           B        ??uip_process_36
   \                     ??uip_process_34:
   \   000002CC   9B0400EA           B        ??uip_process_6
   \                     ??uip_process_36:
   \   000002D0   240C9FE5           LDR      R0,??uip_process_2+0x40  ;; uip_buf + 21
   \   000002D4   0000D0E5           LDRB     R0,[R0, #+0]
   \   000002D8   000050E3           CMP      R0,#+0
   \   000002DC   0000000A           BEQ      ??uip_process_37
    891          //#if UIP_REASSEMBLY
    892          //    uip_len = uip_reass();
    893          //    if(uip_len == 0) {
    894          //      goto drop;
    895          //    }
    896          //#else /* UIP_REASSEMBLY */
    897              UIP_STAT(++uip_stat.ip.drop);
    898              UIP_STAT(++uip_stat.ip.fragerr);
    899              UIP_LOG("ip: fragment dropped.");
    900              goto drop;
   \                     ??uip_process_35:
   \   000002E0   960400EA           B        ??uip_process_6
    901          //#endif /* UIP_REASSEMBLY */
    902            }
    903          #endif /* UIP_CONF_IPV6 */
    904          
    905            if(uip_ipaddr_cmp(uip_hostaddr, all_zeroes_addr)) {
   \                     ??uip_process_37:
   \   000002E4   140C9FE5           LDR      R0,??uip_process_2+0x44  ;; uip_hostaddr
   \   000002E8   B000D0E1           LDRH     R0,[R0, #+0]
   \   000002EC   101C9FE5           LDR      R1,??uip_process_2+0x48  ;; all_zeroes_addr
   \   000002F0   B010D1E1           LDRH     R1,[R1, #+0]
   \   000002F4   010050E1           CMP      R0,R1
   \   000002F8   0500001A           BNE      ??uip_process_38
   \   000002FC   040C9FE5           LDR      R0,??uip_process_2+0x4C  ;; uip_hostaddr + 2
   \   00000300   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000304   001C9FE5           LDR      R1,??uip_process_2+0x50  ;; all_zeroes_addr + 2
   \   00000308   B010D1E1           LDRH     R1,[R1, #+0]
   \   0000030C   010050E1           CMP      R0,R1
   \   00000310   0C00000A           BEQ      ??uip_process_39
    906              /* If we are configured to use ping IP address configuration and
    907                 hasn't been assigned an IP address yet, we accept all ICMP
    908                 packets. */
    909          //#if UIP_PINGADDRCONF && !UIP_CONF_IPV6
    910          //    if(BUF->proto == UIP_PROTO_ICMP) {
    911          //      UIP_LOG("ip: possible ping config packet received.");
    912          //      goto icmp_input;
    913          //    } else {
    914          //      UIP_LOG("ip: packet dropped since no address assigned.");
    915          //      goto drop;
    916          //    }
    917          //#endif /* UIP_PINGADDRCONF */
    918          
    919            } else {
    920              /* If IP broadcast support is configured, we check for a broadcast
    921                 UDP packet, which may be destined to us. */
    922          //#if UIP_BROADCAST
    923          //    DEBUG_PRINTF("UDP IP checksum 0x%04x\n", uip_ipchksum());
    924          //    if(BUF->proto == UIP_PROTO_UDP &&
    925          //       uip_ipaddr_cmp(BUF->destipaddr, all_ones_addr)
    926          //       /*&&
    927          //	 uip_ipchksum() == 0xffff*/) {
    928          //      goto udp_input;
    929          //    }
    930          //#endif /* UIP_BROADCAST */
    931          
    932              /* Check if the packet is destined for our IP address. */
    933          //#if !UIP_CONF_IPV6
    934              if(!uip_ipaddr_cmp(BUF->destipaddr, uip_hostaddr)) {
   \                     ??uip_process_38:
   \   00000314   F40B9FE5           LDR      R0,??uip_process_2+0x54  ;; uip_buf + 30
   \   00000318   B000D0E1           LDRH     R0,[R0, #+0]
   \   0000031C   DC1B9FE5           LDR      R1,??uip_process_2+0x44  ;; uip_hostaddr
   \   00000320   B010D1E1           LDRH     R1,[R1, #+0]
   \   00000324   010050E1           CMP      R0,R1
   \   00000328   0500001A           BNE      ??uip_process_40
   \   0000032C   E00B9FE5           LDR      R0,??uip_process_2+0x58  ;; uip_buf + 32
   \   00000330   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000334   CC1B9FE5           LDR      R1,??uip_process_2+0x4C  ;; uip_hostaddr + 2
   \   00000338   B010D1E1           LDRH     R1,[R1, #+0]
   \   0000033C   010050E1           CMP      R0,R1
   \   00000340   0000000A           BEQ      ??uip_process_41
    935                UIP_STAT(++uip_stat.ip.drop);
    936                goto drop;
   \                     ??uip_process_40:
   \   00000344   7D0400EA           B        ??uip_process_6
    937              }
    938          //#else /* UIP_CONF_IPV6 */
    939          //    /* For IPv6, packet reception is a little trickier as we need to
    940          //       make sure that we listen to certain multicast addresses (all
    941          //       hosts multicast address, and the solicited-node multicast
    942          //       address) as well. However, we will cheat here and accept all
    943          //       multicast packets that are sent to the ff02::/16 addresses. */
    944          //    if(!uip_ipaddr_cmp(BUF->destipaddr, uip_hostaddr) &&
    945          //       BUF->destipaddr[0] != HTONS(0xff02)) {
    946          //      UIP_STAT(++uip_stat.ip.drop);
    947          //      goto drop;
    948          //    }
    949          //#endif /* UIP_CONF_IPV6 */
    950            }
    951          
    952          #if !UIP_CONF_IPV6
    953            if(uip_ipchksum() != 0xffff) { /* Compute and check the IP header
   \                     ??uip_process_41:
   \                     ??uip_process_39:
   \   00000348   ........           BL       uip_ipchksum
   \   0000034C   FF10A0E3           MOV      R1,#+255
   \   00000350   FF1C81E3           ORR      R1,R1,#0xFF00
   \   00000354   010050E1           CMP      R0,R1
   \   00000358   7804001A           BNE      ??uip_process_6
    954          				    checksum. */
    955              UIP_STAT(++uip_stat.ip.drop);
    956              UIP_STAT(++uip_stat.ip.chkerr);
    957              UIP_LOG("ip: bad checksum.");
    958              goto drop;
    959            }
    960          #endif /* UIP_CONF_IPV6 */
    961          
    962            if(BUF->proto == UIP_PROTO_TCP) { /* Check for TCP packet. If so,
   \                     ??uip_process_42:
   \   0000035C   B40B9FE5           LDR      R0,??uip_process_2+0x5C  ;; uip_buf + 23
   \   00000360   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000364   060050E3           CMP      R0,#+6
   \   00000368   0500001A           BNE      ??uip_process_43
    963          				       proceed with TCP input
    964          				       processing. */
    965              goto tcp_input;
    966            }
    967          //
    968          //#if UIP_UDP
    969          //  if(BUF->proto == UIP_PROTO_UDP) {
    970          //    goto udp_input;
    971          //  }
    972          //#endif /* UIP_UDP */
    973          
    974          //#if !UIP_CONF_IPV6
    975            /* ICMPv4 processing code follows. */
    976            if(BUF->proto != UIP_PROTO_ICMP) { /* We only allow ICMP packets from
    977          					here. */
    978              UIP_STAT(++uip_stat.ip.drop);
    979              UIP_STAT(++uip_stat.ip.protoerr);
    980              UIP_LOG("ip: neither tcp nor icmp.");
    981              goto drop;
    982            }
    983          
    984          //#if UIP_PINGADDRCONF
    985          // icmp_input:
    986          //#endif /* UIP_PINGADDRCONF */
    987            UIP_STAT(++uip_stat.icmp.recv);
    988          
    989            //     
    990            if((ICMPBUF->type == ICMP_ECHO_REPLY)&&(ping_flag&(1<<1)))
    991            {
    992          	ping_flag |= (1<<0); // Destination device send ICMP ansver and ping_flag is set
    993          	ping_flag &= ~(1<<1);
    994          	uip_len = 0;
    995          	uip_flags = 0;
    996          	return;
    997            }
    998          
    999          
   1000            /* ICMP echo (i.e., ping) processing. This is simple, we only change
   1001               the ICMP type from ECHO to ECHO_REPLY and adjust the ICMP
   1002               checksum before we return the packet. */
   1003            if(ICMPBUF->type != ICMP_ECHO) 
   1004            {
   1005              UIP_STAT(++uip_stat.icmp.drop);
   1006              UIP_STAT(++uip_stat.icmp.typeerr);
   1007              UIP_LOG("icmp: not icmp echo.");
   1008          //		ping_flag = 1; // Destination device send ICMP ansver and ping_flag is set
   1009              goto drop;
   1010            }
   1011          
   1012          
   1013          
   1014          
   1015          //if(ICMPBUF->type == ICMP_ECHO_REPLY)
   1016          //{
   1017          //  UIP_STAT(++uip_stat.icmp.drop);
   1018          //  UIP_STAT(++uip_stat.icmp.typeerr);
   1019          //  UIP_LOG("icmp: not icmp echo.");
   1020          //  ping_flag = 1; // Destination device send ICMP ansver and ping_flag is set
   1021          //  goto drop;
   1022          //}
   1023          
   1024          //  /* If we are configured to use ping IP address assignment, we use
   1025          //     the destination IP address of this ping packet and assign it to
   1026          //     ourself. */
   1027          //#if UIP_PINGADDRCONF
   1028          //  if((uip_hostaddr[0] | uip_hostaddr[1]) == 0) {
   1029          //    uip_hostaddr[0] = BUF->destipaddr[0];
   1030          //    uip_hostaddr[1] = BUF->destipaddr[1];
   1031          //  }
   1032          //#endif /* UIP_PINGADDRCONF */
   1033          
   1034            ICMPBUF->type = ICMP_ECHO_REPLY;
   1035          
   1036            if(ICMPBUF->icmpchksum >= HTONS(0xffff - (ICMP_ECHO << 8))) {
   1037              ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8) + 1;
   1038            } else {
   1039              ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8);
   1040            }
   1041          
   1042            /* Swap IP addresses. */
   1043            uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
   1044            uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
   1045          
   1046            UIP_STAT(++uip_stat.icmp.sent);
   1047            goto send;
   1048          
   1049            /* End of IPv4 input header processing code. */
   1050          //#else /* !UIP_CONF_IPV6 */
   1051          //
   1052          //  /* This is IPv6 ICMPv6 processing code. */
   1053          //  DEBUG_PRINTF("icmp6_input: length %d\n", uip_len);
   1054          //
   1055          //  if(BUF->proto != UIP_PROTO_ICMP6) { /* We only allow ICMPv6 packets from
   1056          //					 here. */
   1057          //    UIP_STAT(++uip_stat.ip.drop);
   1058          //    UIP_STAT(++uip_stat.ip.protoerr);
   1059          //    UIP_LOG("ip: neither tcp nor icmp6.");
   1060          //    goto drop;
   1061          //  }
   1062          //
   1063          //  UIP_STAT(++uip_stat.icmp.recv);
   1064          //
   1065          //  /* If we get a neighbor solicitation for our address we should send
   1066          //     a neighbor advertisement message back. */
   1067          //  if(ICMPBUF->type == ICMP6_NEIGHBOR_SOLICITATION) {
   1068          //    if(uip_ipaddr_cmp(ICMPBUF->icmp6data, uip_hostaddr)) {
   1069          //
   1070          //      if(ICMPBUF->options[0] == ICMP6_OPTION_SOURCE_LINK_ADDRESS) {
   1071          //	/* Save the sender's address in our neighbor list. */
   1072          //	uip_neighbor_add(ICMPBUF->srcipaddr, &(ICMPBUF->options[2]));
   1073          //      }
   1074          //
   1075          //      /* We should now send a neighbor advertisement back to where the
   1076          //	 neighbor solicication came from. */
   1077          //      ICMPBUF->type = ICMP6_NEIGHBOR_ADVERTISEMENT;
   1078          //      ICMPBUF->flags = ICMP6_FLAG_S; /* Solicited flag. */
   1079          //
   1080          //      ICMPBUF->reserved1 = ICMPBUF->reserved2 = ICMPBUF->reserved3 = 0;
   1081          //
   1082          //      uip_ipaddr_copy(ICMPBUF->destipaddr, ICMPBUF->srcipaddr);
   1083          //      uip_ipaddr_copy(ICMPBUF->srcipaddr, uip_hostaddr);
   1084          //      ICMPBUF->options[0] = ICMP6_OPTION_TARGET_LINK_ADDRESS;
   1085          //      ICMPBUF->options[1] = 1;  /* Options length, 1 = 8 bytes. */
   1086          //      memcpy(&(ICMPBUF->options[2]), &uip_ethaddr, sizeof(uip_ethaddr));
   1087          //      ICMPBUF->icmpchksum = 0;
   1088          //      ICMPBUF->icmpchksum = ~uip_icmp6chksum();
   1089          //      goto send;
   1090          //
   1091          //    }
   1092          //    goto drop;
   1093          //  } else if(ICMPBUF->type == ICMP6_ECHO) {
   1094          //    /* ICMP echo (i.e., ping) processing. This is simple, we only
   1095          //       change the ICMP type from ECHO to ECHO_REPLY and update the
   1096          //       ICMP checksum before we return the packet. */
   1097          //
   1098          //    ICMPBUF->type = ICMP6_ECHO_REPLY;
   1099          //
   1100          //    uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
   1101          //    uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
   1102          //    ICMPBUF->icmpchksum = 0;
   1103          //    ICMPBUF->icmpchksum = ~uip_icmp6chksum();
   1104          //
   1105          //    UIP_STAT(++uip_stat.icmp.sent);
   1106          //    goto send;
   1107          //  } else {
   1108          //    DEBUG_PRINTF("Unknown icmp6 message type %d\n", ICMPBUF->type);
   1109          //    UIP_STAT(++uip_stat.icmp.drop);
   1110          //    UIP_STAT(++uip_stat.icmp.typeerr);
   1111          //    UIP_LOG("icmp: unknown ICMP message.");
   1112          //    goto drop;
   1113          //  }
   1114          //
   1115          //  /* End of IPv6 ICMP processing. */
   1116          //
   1117          //#endif /* !UIP_CONF_IPV6 */
   1118          
   1119          //#if UIP_UDP
   1120          //  /* UDP input processing. */
   1121          // udp_input:
   1122          //  /* UDP processing is really just a hack. We don't do anything to the
   1123          //     UDP/IP headers, but let the UDP application do all the hard
   1124          //     work. If the application sets uip_slen, it has a packet to
   1125          //     send. */
   1126          ////#if UIP_UDP_CHECKSUMS
   1127          ////  uip_len = uip_len - UIP_IPUDPH_LEN;
   1128          ////  uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
   1129          ////  if(UDPBUF->udpchksum != 0 && uip_udpchksum() != 0xffff) {
   1130          ////    UIP_STAT(++uip_stat.udp.drop);
   1131          ////    UIP_STAT(++uip_stat.udp.chkerr);
   1132          ////    UIP_LOG("udp: bad checksum.");
   1133          ////    goto drop;
   1134          ////  }
   1135          ////#else /* UIP_UDP_CHECKSUMS */
   1136          //  uip_len = uip_len - UIP_IPUDPH_LEN;
   1137          //#endif /* UIP_UDP_CHECKSUMS */
   1138          //
   1139          //  /* Demultiplex this UDP packet between the UDP "connections". */
   1140          //  for(uip_udp_conn = &uip_udp_conns[0];
   1141          //      uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
   1142          //      ++uip_udp_conn) {
   1143          //    /* If the local UDP port is non-zero, the connection is considered
   1144          //       to be used. If so, the local port number is checked against the
   1145          //       destination port number in the received packet. If the two port
   1146          //       numbers match, the remote port number is checked if the
   1147          //       connection is bound to a remote port. Finally, if the
   1148          //       connection is bound to a remote IP address, the source IP
   1149          //       address of the packet is checked. */
   1150          //    if(uip_udp_conn->lport != 0 &&
   1151          //       UDPBUF->destport == uip_udp_conn->lport &&
   1152          //       (uip_udp_conn->rport == 0 ||
   1153          //        UDPBUF->srcport == uip_udp_conn->rport) &&
   1154          //       (uip_ipaddr_cmp(uip_udp_conn->ripaddr, all_zeroes_addr) ||
   1155          //	uip_ipaddr_cmp(uip_udp_conn->ripaddr, all_ones_addr) ||
   1156          //	uip_ipaddr_cmp(BUF->srcipaddr, uip_udp_conn->ripaddr))) {
   1157          //      goto udp_found;
   1158          //    }
   1159          //  }
   1160          //  UIP_LOG("udp: no matching connection found");
   1161          //  goto drop;
   1162          //
   1163          // udp_found:
   1164          //  UIP_STAT(++uip_stat.udp.recv);
   1165          //  uip_conn = NULL;
   1166          //  uip_flags = UIP_NEWDATA;
   1167          //  uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
   1168          //  uip_slen = 0;
   1169          //  UIP_UDP_APPCALL();
   1170          // udp_send:
   1171          //  if(uip_slen == 0) {
   1172          //    goto drop;
   1173          //  }
   1174          //  uip_len = uip_slen + UIP_IPUDPH_LEN;
   1175          //
   1176          //#if UIP_CONF_IPV6
   1177          //  /* For IPv6, the IP length field does not include the IPv6 IP header
   1178          //     length. */
   1179          //  BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
   1180          //  BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
   1181          //#else /* UIP_CONF_IPV6 */
   1182          //  BUF->len[0] = (uip_len >> 8);
   1183          //  BUF->len[1] = (uip_len & 0xff);
   1184          //#endif /* UIP_CONF_IPV6 */
   1185          //
   1186          //  BUF->ttl = uip_udp_conn->ttl;
   1187          //  BUF->proto = UIP_PROTO_UDP;
   1188          //
   1189          //  UDPBUF->udplen = HTONS(uip_slen + UIP_UDPH_LEN);
   1190          //  UDPBUF->udpchksum = 0;
   1191          //
   1192          //  BUF->srcport  = uip_udp_conn->lport;
   1193          //  BUF->destport = uip_udp_conn->rport;
   1194          //
   1195          //  uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
   1196          //  uip_ipaddr_copy(BUF->destipaddr, uip_udp_conn->ripaddr);
   1197          //
   1198          //  uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPTCPH_LEN];
   1199          //
   1200          //#if UIP_UDP_CHECKSUMS
   1201          //  /* Calculate UDP checksum. */
   1202          //  UDPBUF->udpchksum = ~(uip_udpchksum());
   1203          //  if(UDPBUF->udpchksum == 0) {
   1204          //    UDPBUF->udpchksum = 0xffff;
   1205          //  }
   1206          //#endif /* UIP_UDP_CHECKSUMS */
   1207          //  UIP_STAT(++uip_stat.udp.sent);
   1208          //  goto ip_send_nolen;
   1209          //#endif /* UIP_UDP */
   1210          
   1211            /* TCP input processing. */
   1212           tcp_input:
   1213            UIP_STAT(++uip_stat.tcp.recv);
   1214          
   1215            /* Start of TCP input header processing code. */
   1216          
   1217            if(uip_tcpchksum() != 0xffff) {   /* Compute and check the TCP
   \   0000036C   ........           BL       uip_tcpchksum
   \   00000370   FF10A0E3           MOV      R1,#+255
   \   00000374   FF1C81E3           ORR      R1,R1,#0xFF00
   \   00000378   010050E1           CMP      R0,R1
   \   0000037C   4600001A           BNE      ??uip_process_44
   \   00000380   460000EA           B        ??uip_process_45
   \                     ??uip_process_43:
   \   00000384   8C0B9FE5           LDR      R0,??uip_process_2+0x5C  ;; uip_buf + 23
   \   00000388   0000D0E5           LDRB     R0,[R0, #+0]
   \   0000038C   010050E3           CMP      R0,#+1
   \   00000390   6A04001A           BNE      ??uip_process_6
   \                     ??uip_process_46:
   \   00000394   800B9FE5           LDR      R0,??uip_process_2+0x60  ;; uip_buf + 34
   \   00000398   0000D0E5           LDRB     R0,[R0, #+0]
   \   0000039C   000050E3           CMP      R0,#+0
   \   000003A0   1400001A           BNE      ??uip_process_47
   \   000003A4   740B9FE5           LDR      R0,??uip_process_2+0x64  ;; ping_flag
   \   000003A8   0000D0E5           LDRB     R0,[R0, #+0]
   \   000003AC   020010E3           TST      R0,#0x2
   \   000003B0   1000000A           BEQ      ??uip_process_47
   \   000003B4   640B9FE5           LDR      R0,??uip_process_2+0x64  ;; ping_flag
   \   000003B8   0000D0E5           LDRB     R0,[R0, #+0]
   \   000003BC   010090E3           ORRS     R0,R0,#0x1
   \   000003C0   581B9FE5           LDR      R1,??uip_process_2+0x64  ;; ping_flag
   \   000003C4   0000C1E5           STRB     R0,[R1, #+0]
   \   000003C8   500B9FE5           LDR      R0,??uip_process_2+0x64  ;; ping_flag
   \   000003CC   0000D0E5           LDRB     R0,[R0, #+0]
   \   000003D0   0200D0E3           BICS     R0,R0,#0x2
   \   000003D4   441B9FE5           LDR      R1,??uip_process_2+0x64  ;; ping_flag
   \   000003D8   0000C1E5           STRB     R0,[R1, #+0]
   \   000003DC   FC0A9FE5           LDR      R0,??uip_process_2+0x24  ;; uip_len
   \   000003E0   0010A0E3           MOV      R1,#+0
   \   000003E4   B010C0E1           STRH     R1,[R0, #+0]
   \   000003E8   DC0A9FE5           LDR      R0,??uip_process_2+0x10  ;; uip_flags
   \   000003EC   0010A0E3           MOV      R1,#+0
   \   000003F0   0010C0E5           STRB     R1,[R0, #+0]
   \   000003F4   570400EA           B        ??uip_process_48
   \                     ??uip_process_47:
   \   000003F8   1C0B9FE5           LDR      R0,??uip_process_2+0x60  ;; uip_buf + 34
   \   000003FC   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000400   080050E3           CMP      R0,#+8
   \   00000404   4D04001A           BNE      ??uip_process_6
   \                     ??uip_process_49:
   \   00000408   0C0B9FE5           LDR      R0,??uip_process_2+0x60  ;; uip_buf + 34
   \   0000040C   0010A0E3           MOV      R1,#+0
   \   00000410   0010C0E5           STRB     R1,[R0, #+0]
   \   00000414   080B9FE5           LDR      R0,??uip_process_2+0x68  ;; uip_buf + 36
   \   00000418   B000D0E1           LDRH     R0,[R0, #+0]
   \   0000041C   F710A0E3           MOV      R1,#+247
   \   00000420   FF1C81E3           ORR      R1,R1,#0xFF00
   \   00000424   010050E1           CMP      R0,R1
   \   00000428   0500003A           BCC      ??uip_process_50
   \   0000042C   F00A9FE5           LDR      R0,??uip_process_2+0x68  ;; uip_buf + 36
   \   00000430   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000434   090090E2           ADDS     R0,R0,#+9
   \   00000438   E41A9FE5           LDR      R1,??uip_process_2+0x68  ;; uip_buf + 36
   \   0000043C   B000C1E1           STRH     R0,[R1, #+0]
   \   00000440   040000EA           B        ??uip_process_51
   \                     ??uip_process_50:
   \   00000444   D80A9FE5           LDR      R0,??uip_process_2+0x68  ;; uip_buf + 36
   \   00000448   B000D0E1           LDRH     R0,[R0, #+0]
   \   0000044C   080090E2           ADDS     R0,R0,#+8
   \   00000450   CC1A9FE5           LDR      R1,??uip_process_2+0x68  ;; uip_buf + 36
   \   00000454   B000C1E1           STRH     R0,[R1, #+0]
   \                     ??uip_process_51:
   \   00000458   B00A9FE5           LDR      R0,??uip_process_2+0x54  ;; uip_buf + 30
   \   0000045C   C41A9FE5           LDR      R1,??uip_process_2+0x6C  ;; uip_buf + 26
   \   00000460   B010D1E1           LDRH     R1,[R1, #+0]
   \   00000464   B010C0E1           STRH     R1,[R0, #+0]
   \   00000468   A40A9FE5           LDR      R0,??uip_process_2+0x58  ;; uip_buf + 32
   \   0000046C   B81A9FE5           LDR      R1,??uip_process_2+0x70  ;; uip_buf + 28
   \   00000470   B010D1E1           LDRH     R1,[R1, #+0]
   \   00000474   B010C0E1           STRH     R1,[R0, #+0]
   \   00000478   A80A9FE5           LDR      R0,??uip_process_2+0x6C  ;; uip_buf + 26
   \   0000047C   7C1A9FE5           LDR      R1,??uip_process_2+0x44  ;; uip_hostaddr
   \   00000480   B010D1E1           LDRH     R1,[R1, #+0]
   \   00000484   B010C0E1           STRH     R1,[R0, #+0]
   \   00000488   9C0A9FE5           LDR      R0,??uip_process_2+0x70  ;; uip_buf + 28
   \   0000048C   741A9FE5           LDR      R1,??uip_process_2+0x4C  ;; uip_hostaddr + 2
   \   00000490   B010D1E1           LDRH     R1,[R1, #+0]
   \   00000494   B010C0E1           STRH     R1,[R0, #+0]
   \   00000498   240400EA           B        ??uip_process_52
   1218          				       checksum. */
   1219              UIP_STAT(++uip_stat.tcp.drop);
   1220              UIP_STAT(++uip_stat.tcp.chkerr);
   1221              UIP_LOG("tcp: bad checksum.");
   1222              goto drop;
   \                     ??uip_process_44:
   \   0000049C   270400EA           B        ??uip_process_6
   1223            }
   1224          
   1225          
   1226            /* Demultiplex this segment. */
   1227            /* First check any active connections. */
   1228            for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
   \                     ??uip_process_45:
   \   000004A0   880A9FE5           LDR      R0,??uip_process_2+0x74  ;; uip_conns
   \   000004A4   0050B0E1           MOVS     R5,R0
   \                     ??uip_process_53:
   \   000004A8   800A9FE5           LDR      R0,??uip_process_2+0x74  ;; uip_conns
   \   000004AC   050050E1           CMP      R0,R5
   \   000004B0   2200003A           BCC      ??uip_process_54
   1229                ++uip_connr) {
   1230              if(uip_connr->tcpstateflags != UIP_CLOSED &&
   1231                 BUF->destport == uip_connr->lport &&
   1232                 BUF->srcport == uip_connr->rport &&
   1233                 uip_ipaddr_cmp(BUF->srcipaddr, uip_connr->ripaddr)) {
   \   000004B4   1900D5E5           LDRB     R0,[R5, #+25]
   \   000004B8   000050E3           CMP      R0,#+0
   \   000004BC   1D00000A           BEQ      ??uip_process_55
   \   000004C0   5C0A9FE5           LDR      R0,??uip_process_2+0x68  ;; uip_buf + 36
   \   000004C4   B000D0E1           LDRH     R0,[R0, #+0]
   \   000004C8   B410D5E1           LDRH     R1,[R5, #+4]
   \   000004CC   010050E1           CMP      R0,R1
   \   000004D0   1800001A           BNE      ??uip_process_55
   \   000004D4   400A9FE5           LDR      R0,??uip_process_2+0x60  ;; uip_buf + 34
   \   000004D8   B000D0E1           LDRH     R0,[R0, #+0]
   \   000004DC   B610D5E1           LDRH     R1,[R5, #+6]
   \   000004E0   010050E1           CMP      R0,R1
   \   000004E4   1300001A           BNE      ??uip_process_55
   \   000004E8   380A9FE5           LDR      R0,??uip_process_2+0x6C  ;; uip_buf + 26
   \   000004EC   B000D0E1           LDRH     R0,[R0, #+0]
   \   000004F0   B010D5E1           LDRH     R1,[R5, #+0]
   \   000004F4   010050E1           CMP      R0,R1
   \   000004F8   0E00001A           BNE      ??uip_process_55
   \   000004FC   280A9FE5           LDR      R0,??uip_process_2+0x70  ;; uip_buf + 28
   \   00000500   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000504   B210D5E1           LDRH     R1,[R5, #+2]
   \   00000508   010050E1           CMP      R0,R1
   \   0000050C   0900001A           BNE      ??uip_process_55
   1234                goto found;
   1235              }
   1236            }
   1237          
   1238            /* If we didn't find and active connection that expected the packet,
   1239               either this packet is an old duplicate, or this is a SYN packet
   1240               destined for a connection in LISTEN. If the SYN flag isn't set,
   1241               it is an old packet and we send a RST. */
   1242            if((BUF->flags & TCP_CTL) != TCP_SYN) {
   1243              goto reset;
   1244            }
   1245          
   1246            tmp16 = BUF->destport;
   1247            /* Next, check listening connections. */
   1248            for(c = 0; c < UIP_LISTENPORTS; ++c) {
   1249              if(tmp16 == uip_listenports[c])
   1250                goto found_listen;
   1251            }
   1252          
   1253            /* No matching connection found, so we send a RST packet. */
   1254            UIP_STAT(++uip_stat.tcp.synrst);
   1255           reset:
   1256          
   1257            /* We do not send resets in response to resets. */
   1258            if(BUF->flags & TCP_RST) {
   1259              goto drop;
   1260            }
   1261          
   1262            UIP_STAT(++uip_stat.tcp.rst);
   1263          
   1264            BUF->flags = TCP_RST | TCP_ACK;
   1265            uip_len = UIP_IPTCPH_LEN;
   1266            BUF->tcpoffset = 5 << 4;
   1267          
   1268            /* Flip the seqno and ackno fields in the TCP header. */
   1269            c = BUF->seqno[3];
   1270            BUF->seqno[3] = BUF->ackno[3];
   1271            BUF->ackno[3] = c;
   1272          
   1273            c = BUF->seqno[2];
   1274            BUF->seqno[2] = BUF->ackno[2];
   1275            BUF->ackno[2] = c;
   1276          
   1277            c = BUF->seqno[1];
   1278            BUF->seqno[1] = BUF->ackno[1];
   1279            BUF->ackno[1] = c;
   1280          
   1281            c = BUF->seqno[0];
   1282            BUF->seqno[0] = BUF->ackno[0];
   1283            BUF->ackno[0] = c;
   1284          
   1285            /* We also have to increase the sequence number we are
   1286               acknowledging. If the least significant byte overflowed, we need
   1287               to propagate the carry to the other bytes as well. */
   1288            if(++BUF->ackno[3] == 0) {
   1289              if(++BUF->ackno[2] == 0) {
   1290                if(++BUF->ackno[1] == 0) {
   1291          	++BUF->ackno[0];
   1292                }
   1293              }
   1294            }
   1295          
   1296            /* Swap port numbers. */
   1297            tmp16 = BUF->srcport;
   1298            BUF->srcport = BUF->destport;
   1299            BUF->destport = tmp16;
   1300          
   1301            /* Swap IP addresses. */
   1302            uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
   1303            uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
   1304          
   1305            /* And send out the RST packet! */
   1306            goto tcp_send_noconn;
   1307          
   1308            /* This label will be jumped to if we matched the incoming packet
   1309               with a connection in LISTEN. In that case, we should create a new
   1310               connection and send a SYNACK in return. */
   1311           found_listen:
   1312            /* First we check if there are any connections avaliable. Unused
   1313               connections are kept in the same table as used connections, but
   1314               unused ones have the tcpstate set to CLOSED. Also, connections in
   1315               TIME_WAIT are kept track of and we'll use the oldest one if no
   1316               CLOSED connections are found. Thanks to Eddie C. Dost for a very
   1317               nice algorithm for the TIME_WAIT search. */
   1318            uip_connr = 0;
   1319            for(c = 0; c < UIP_CONNS; ++c) {
   1320              if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
   1321                uip_connr = &uip_conns[c];
   1322                break;
   1323              }
   1324              if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
   1325                if(uip_connr == 0 ||
   1326          	 uip_conns[c].timer > uip_connr->timer) {
   1327          	uip_connr = &uip_conns[c];
   1328                }
   1329              }
   1330            }
   1331          
   1332            if(uip_connr == 0) {
   1333              /* All connections are used already, we drop packet and hope that
   1334                 the remote end will retransmit the packet at a time when we
   1335                 have more spare connections. */
   1336              UIP_STAT(++uip_stat.tcp.syndrop);
   1337              UIP_LOG("tcp: found no unused connections.");
   1338              goto drop;
   1339            }
   1340            uip_conn = uip_connr;
   1341          
   1342            /* Fill in the necessary fields for the new connection. */
   1343            uip_connr->rto = uip_connr->timer = UIP_RTO;
   1344            uip_connr->sa = 0;
   1345            uip_connr->sv = 4;
   1346            uip_connr->nrtx = 0;
   1347            uip_connr->lport = BUF->destport;
   1348            uip_connr->rport = BUF->srcport;
   1349            uip_ipaddr_copy(uip_connr->ripaddr, BUF->srcipaddr);
   1350            uip_connr->tcpstateflags = UIP_SYN_RCVD;
   1351          
   1352            uip_connr->snd_nxt[0] = iss[0];
   1353            uip_connr->snd_nxt[1] = iss[1];
   1354            uip_connr->snd_nxt[2] = iss[2];
   1355            uip_connr->snd_nxt[3] = iss[3];
   1356            uip_connr->len = 1;
   1357          
   1358            /* rcv_nxt should be the seqno from the incoming packet + 1. */
   1359            uip_connr->rcv_nxt[3] = BUF->seqno[3];
   1360            uip_connr->rcv_nxt[2] = BUF->seqno[2];
   1361            uip_connr->rcv_nxt[1] = BUF->seqno[1];
   1362            uip_connr->rcv_nxt[0] = BUF->seqno[0];
   1363            uip_add_rcv_nxt(1);
   1364          
   1365            /* Parse the TCP MSS option, if present. */
   1366            if((BUF->tcpoffset & 0xf0) > 0x50) {
   1367              for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
   1368                opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
   1369                if(opt == TCP_OPT_END) {
   1370          	/* End of options. */
   1371          	break;
   1372                } else if(opt == TCP_OPT_NOOP) {
   1373          	++c;
   1374          	/* NOP option. */
   1375                } else if(opt == TCP_OPT_MSS &&
   1376          		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
   1377          	/* An MSS option with the right option length. */
   1378          	tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
   1379          	  (u16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
   1380          	uip_connr->initialmss = uip_connr->mss =
   1381          	  tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
   1382          	
   1383          	/* And we are done processing options. */
   1384          	break;
   1385                } else {
   1386          	/* All other options have a length field, so that we easily
   1387          	   can skip past them. */
   1388          	if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
   1389          	  /* If the length field is zero, the options are malformed
   1390          	     and we don't process them further. */
   1391          	  break;
   1392          	}
   1393          	c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
   1394                }
   1395              }
   1396            }
   1397          
   1398            /* Our response will be a SYNACK. */
   1399          #if UIP_ACTIVE_OPEN
   1400           tcp_send_synack:
   1401            BUF->flags = TCP_ACK;
   1402          
   1403           tcp_send_syn:
   1404            BUF->flags |= TCP_SYN;
   1405          #else /* UIP_ACTIVE_OPEN */
   1406           tcp_send_synack:
   1407            BUF->flags = TCP_SYN | TCP_ACK;
   1408          #endif /* UIP_ACTIVE_OPEN */
   1409          
   1410            /* We send out the TCP Maximum Segment Size option with our
   1411               SYNACK. */
   1412            BUF->optdata[0] = TCP_OPT_MSS;
   1413            BUF->optdata[1] = TCP_OPT_MSS_LEN;
   1414            BUF->optdata[2] = (UIP_TCP_MSS) / 256;
   1415            BUF->optdata[3] = (UIP_TCP_MSS) & 255;
   1416            uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
   1417            BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;
   1418            goto tcp_send;
   1419          
   1420            /* This label will be jumped to if we found an active connection. */
   1421           found:
   1422            uip_conn = uip_connr;
   \   00000510   A4099FE5           LDR      R0,??uip_process_2  ;; uip_conn
   \   00000514   005080E5           STR      R5,[R0, #+0]
   1423            uip_flags = 0;
   \   00000518   AC099FE5           LDR      R0,??uip_process_2+0x10  ;; uip_flags
   \   0000051C   0010A0E3           MOV      R1,#+0
   \   00000520   0010C0E5           STRB     R1,[R0, #+0]
   1424            /* We do a very naive form of TCP reset processing; we just accept
   1425               any RST and kill our connection. We should in fact check if the
   1426               sequence number of this reset is wihtin our advertised window
   1427               before we accept the reset. */
   1428            if(BUF->flags & TCP_RST) {
   \   00000524   BC099FE5           LDR      R0,??uip_process_2+0x2C  ;; uip_buf + 47
   \   00000528   0000D0E5           LDRB     R0,[R0, #+0]
   \   0000052C   040010E3           TST      R0,#0x4
   \   00000530   7D01001A           BNE      ??uip_process_56
   \   00000534   830100EA           B        ??uip_process_57
   \                     ??uip_process_55:
   \   00000538   A85095E2           ADDS     R5,R5,#+168
   \   0000053C   D9FFFFEA           B        ??uip_process_53
   \                     ??uip_process_54:
   \   00000540   A0099FE5           LDR      R0,??uip_process_2+0x2C  ;; uip_buf + 47
   \   00000544   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000548   3F0010E2           ANDS     R0,R0,#0x3F
   \   0000054C   020050E3           CMP      R0,#+2
   \   00000550   2000001A           BNE      ??uip_process_58
   \                     ??uip_process_59:
   \   00000554   C8099FE5           LDR      R0,??uip_process_2+0x68  ;; uip_buf + 36
   \   00000558   B000D0E1           LDRH     R0,[R0, #+0]
   \   0000055C   D0199FE5           LDR      R1,??uip_process_2+0x78  ;; tmp16
   \   00000560   B000C1E1           STRH     R0,[R1, #+0]
   \   00000564   CC099FE5           LDR      R0,??uip_process_2+0x7C  ;; c
   \   00000568   0010A0E3           MOV      R1,#+0
   \   0000056C   0010C0E5           STRB     R1,[R0, #+0]
   \                     ??uip_process_60:
   \   00000570   C0099FE5           LDR      R0,??uip_process_2+0x7C  ;; c
   \   00000574   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000578   010050E3           CMP      R0,#+1
   \   0000057C   1500002A           BCS      ??uip_process_61
   \   00000580   AC099FE5           LDR      R0,??uip_process_2+0x78  ;; tmp16
   \   00000584   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000588   A8199FE5           LDR      R1,??uip_process_2+0x7C  ;; c
   \   0000058C   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000590   0220A0E3           MOV      R2,#+2
   \   00000594   A0399FE5           LDR      R3,??uip_process_2+0x80  ;; uip_listenports
   \   00000598   923121E0           MLA      R1,R2,R1,R3
   \   0000059C   B010D1E1           LDRH     R1,[R1, #+0]
   \   000005A0   010050E1           CMP      R0,R1
   \   000005A4   0500001A           BNE      ??uip_process_62
   \   000005A8   0000A0E3           MOV      R0,#+0
   \   000005AC   0050B0E1           MOVS     R5,R0
   \   000005B0   80099FE5           LDR      R0,??uip_process_2+0x7C  ;; c
   \   000005B4   0010A0E3           MOV      R1,#+0
   \   000005B8   0010C0E5           STRB     R1,[R0, #+0]
   \   000005BC   7C0000EA           B        ??uip_process_63
   \                     ??uip_process_62:
   \   000005C0   70099FE5           LDR      R0,??uip_process_2+0x7C  ;; c
   \   000005C4   0000D0E5           LDRB     R0,[R0, #+0]
   \   000005C8   010090E2           ADDS     R0,R0,#+1
   \   000005CC   64199FE5           LDR      R1,??uip_process_2+0x7C  ;; c
   \   000005D0   0000C1E5           STRB     R0,[R1, #+0]
   \   000005D4   E5FFFFEA           B        ??uip_process_60
   \                     ??uip_process_61:
   \                     ??uip_process_58:
   \   000005D8   08099FE5           LDR      R0,??uip_process_2+0x2C  ;; uip_buf + 47
   \   000005DC   0000D0E5           LDRB     R0,[R0, #+0]
   \   000005E0   040010E3           TST      R0,#0x4
   \   000005E4   D503001A           BNE      ??uip_process_6
   \                     ??uip_process_64:
   \   000005E8   F8089FE5           LDR      R0,??uip_process_2+0x2C  ;; uip_buf + 47
   \   000005EC   1410A0E3           MOV      R1,#+20
   \   000005F0   0010C0E5           STRB     R1,[R0, #+0]
   \   000005F4   E4089FE5           LDR      R0,??uip_process_2+0x24  ;; uip_len
   \   000005F8   2810A0E3           MOV      R1,#+40
   \   000005FC   B010C0E1           STRH     R1,[R0, #+0]
   \   00000600   580F9FE5           LDR      R0,??uip_process_65  ;; uip_buf + 46
   \   00000604   5010A0E3           MOV      R1,#+80
   \   00000608   0010C0E5           STRB     R1,[R0, #+0]
   \   0000060C   500F9FE5           LDR      R0,??uip_process_65+0x4  ;; uip_buf + 41
   \   00000610   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000614   1C199FE5           LDR      R1,??uip_process_2+0x7C  ;; c
   \   00000618   0000C1E5           STRB     R0,[R1, #+0]
   \   0000061C   400F9FE5           LDR      R0,??uip_process_65+0x4  ;; uip_buf + 41
   \   00000620   401F9FE5           LDR      R1,??uip_process_65+0x8  ;; uip_buf + 45
   \   00000624   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000628   0010C0E5           STRB     R1,[R0, #+0]
   \   0000062C   340F9FE5           LDR      R0,??uip_process_65+0x8  ;; uip_buf + 45
   \   00000630   00199FE5           LDR      R1,??uip_process_2+0x7C  ;; c
   \   00000634   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000638   0010C0E5           STRB     R1,[R0, #+0]
   \   0000063C   280F9FE5           LDR      R0,??uip_process_65+0xC  ;; uip_buf + 40
   \   00000640   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000644   EC189FE5           LDR      R1,??uip_process_2+0x7C  ;; c
   \   00000648   0000C1E5           STRB     R0,[R1, #+0]
   \   0000064C   180F9FE5           LDR      R0,??uip_process_65+0xC  ;; uip_buf + 40
   \   00000650   181F9FE5           LDR      R1,??uip_process_65+0x10  ;; uip_buf + 44
   \   00000654   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000658   0010C0E5           STRB     R1,[R0, #+0]
   \   0000065C   0C0F9FE5           LDR      R0,??uip_process_65+0x10  ;; uip_buf + 44
   \   00000660   D0189FE5           LDR      R1,??uip_process_2+0x7C  ;; c
   \   00000664   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000668   0010C0E5           STRB     R1,[R0, #+0]
   \   0000066C   000F9FE5           LDR      R0,??uip_process_65+0x14  ;; uip_buf + 39
   \   00000670   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000674   BC189FE5           LDR      R1,??uip_process_2+0x7C  ;; c
   \   00000678   0000C1E5           STRB     R0,[R1, #+0]
   \   0000067C   F00E9FE5           LDR      R0,??uip_process_65+0x14  ;; uip_buf + 39
   \   00000680   F01E9FE5           LDR      R1,??uip_process_65+0x18  ;; uip_buf + 43
   \   00000684   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000688   0010C0E5           STRB     R1,[R0, #+0]
   \   0000068C   E40E9FE5           LDR      R0,??uip_process_65+0x18  ;; uip_buf + 43
   \   00000690   A0189FE5           LDR      R1,??uip_process_2+0x7C  ;; c
   \   00000694   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000698   0010C0E5           STRB     R1,[R0, #+0]
   \   0000069C   D80E9FE5           LDR      R0,??uip_process_65+0x1C  ;; uip_buf + 38
   \   000006A0   0000D0E5           LDRB     R0,[R0, #+0]
   \   000006A4   8C189FE5           LDR      R1,??uip_process_2+0x7C  ;; c
   \   000006A8   0000C1E5           STRB     R0,[R1, #+0]
   \   000006AC   C80E9FE5           LDR      R0,??uip_process_65+0x1C  ;; uip_buf + 38
   \   000006B0   C81E9FE5           LDR      R1,??uip_process_65+0x20  ;; uip_buf + 42
   \   000006B4   0010D1E5           LDRB     R1,[R1, #+0]
   \   000006B8   0010C0E5           STRB     R1,[R0, #+0]
   \   000006BC   BC0E9FE5           LDR      R0,??uip_process_65+0x20  ;; uip_buf + 42
   \   000006C0   70189FE5           LDR      R1,??uip_process_2+0x7C  ;; c
   \   000006C4   0010D1E5           LDRB     R1,[R1, #+0]
   \   000006C8   0010C0E5           STRB     R1,[R0, #+0]
   \   000006CC   940E9FE5           LDR      R0,??uip_process_65+0x8  ;; uip_buf + 45
   \   000006D0   0000D0E5           LDRB     R0,[R0, #+0]
   \   000006D4   010090E2           ADDS     R0,R0,#+1
   \   000006D8   881E9FE5           LDR      R1,??uip_process_65+0x8  ;; uip_buf + 45
   \   000006DC   0000C1E5           STRB     R0,[R1, #+0]
   \   000006E0   FF0010E2           ANDS     R0,R0,#0xFF      ;; Zero extend
   \   000006E4   000050E3           CMP      R0,#+0
   \   000006E8   1400001A           BNE      ??uip_process_66
   \   000006EC   7C0E9FE5           LDR      R0,??uip_process_65+0x10  ;; uip_buf + 44
   \   000006F0   0000D0E5           LDRB     R0,[R0, #+0]
   \   000006F4   010090E2           ADDS     R0,R0,#+1
   \   000006F8   701E9FE5           LDR      R1,??uip_process_65+0x10  ;; uip_buf + 44
   \   000006FC   0000C1E5           STRB     R0,[R1, #+0]
   \   00000700   FF0010E2           ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000704   000050E3           CMP      R0,#+0
   \   00000708   0C00001A           BNE      ??uip_process_67
   \   0000070C   640E9FE5           LDR      R0,??uip_process_65+0x18  ;; uip_buf + 43
   \   00000710   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000714   010090E2           ADDS     R0,R0,#+1
   \   00000718   581E9FE5           LDR      R1,??uip_process_65+0x18  ;; uip_buf + 43
   \   0000071C   0000C1E5           STRB     R0,[R1, #+0]
   \   00000720   FF0010E2           ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000724   000050E3           CMP      R0,#+0
   \   00000728   0400001A           BNE      ??uip_process_68
   \   0000072C   4C0E9FE5           LDR      R0,??uip_process_65+0x20  ;; uip_buf + 42
   \   00000730   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000734   010090E2           ADDS     R0,R0,#+1
   \   00000738   401E9FE5           LDR      R1,??uip_process_65+0x20  ;; uip_buf + 42
   \   0000073C   0000C1E5           STRB     R0,[R1, #+0]
   \                     ??uip_process_68:
   \                     ??uip_process_67:
   \                     ??uip_process_66:
   \   00000740   D4079FE5           LDR      R0,??uip_process_2+0x60  ;; uip_buf + 34
   \   00000744   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000748   E4179FE5           LDR      R1,??uip_process_2+0x78  ;; tmp16
   \   0000074C   B000C1E1           STRH     R0,[R1, #+0]
   \   00000750   C4079FE5           LDR      R0,??uip_process_2+0x60  ;; uip_buf + 34
   \   00000754   C8179FE5           LDR      R1,??uip_process_2+0x68  ;; uip_buf + 36
   \   00000758   B010D1E1           LDRH     R1,[R1, #+0]
   \   0000075C   B010C0E1           STRH     R1,[R0, #+0]
   \   00000760   BC079FE5           LDR      R0,??uip_process_2+0x68  ;; uip_buf + 36
   \   00000764   C8179FE5           LDR      R1,??uip_process_2+0x78  ;; tmp16
   \   00000768   B010D1E1           LDRH     R1,[R1, #+0]
   \   0000076C   B010C0E1           STRH     R1,[R0, #+0]
   \   00000770   98079FE5           LDR      R0,??uip_process_2+0x54  ;; uip_buf + 30
   \   00000774   AC179FE5           LDR      R1,??uip_process_2+0x6C  ;; uip_buf + 26
   \   00000778   B010D1E1           LDRH     R1,[R1, #+0]
   \   0000077C   B010C0E1           STRH     R1,[R0, #+0]
   \   00000780   8C079FE5           LDR      R0,??uip_process_2+0x58  ;; uip_buf + 32
   \   00000784   A0179FE5           LDR      R1,??uip_process_2+0x70  ;; uip_buf + 28
   \   00000788   B010D1E1           LDRH     R1,[R1, #+0]
   \   0000078C   B010C0E1           STRH     R1,[R0, #+0]
   \   00000790   90079FE5           LDR      R0,??uip_process_2+0x6C  ;; uip_buf + 26
   \   00000794   64179FE5           LDR      R1,??uip_process_2+0x44  ;; uip_hostaddr
   \   00000798   B010D1E1           LDRH     R1,[R1, #+0]
   \   0000079C   B010C0E1           STRH     R1,[R0, #+0]
   \   000007A0   84079FE5           LDR      R0,??uip_process_2+0x70  ;; uip_buf + 28
   \   000007A4   5C179FE5           LDR      R1,??uip_process_2+0x4C  ;; uip_hostaddr + 2
   \   000007A8   B010D1E1           LDRH     R1,[R1, #+0]
   \   000007AC   B010C0E1           STRH     R1,[R0, #+0]
   \   000007B0   260300EA           B        ??uip_process_69
   \                     ??uip_process_63:
   \   000007B4   7C079FE5           LDR      R0,??uip_process_2+0x7C  ;; c
   \   000007B8   0000D0E5           LDRB     R0,[R0, #+0]
   \   000007BC   010050E3           CMP      R0,#+1
   \   000007C0   2D00002A           BCS      ??uip_process_70
   \   000007C4   6C079FE5           LDR      R0,??uip_process_2+0x7C  ;; c
   \   000007C8   0000D0E5           LDRB     R0,[R0, #+0]
   \   000007CC   A810A0E3           MOV      R1,#+168
   \   000007D0   58279FE5           LDR      R2,??uip_process_2+0x74  ;; uip_conns
   \   000007D4   912020E0           MLA      R0,R1,R0,R2
   \   000007D8   1900D0E5           LDRB     R0,[R0, #+25]
   \   000007DC   000050E3           CMP      R0,#+0
   \   000007E0   0600001A           BNE      ??uip_process_71
   \   000007E4   4C079FE5           LDR      R0,??uip_process_2+0x7C  ;; c
   \   000007E8   0000D0E5           LDRB     R0,[R0, #+0]
   \   000007EC   A810A0E3           MOV      R1,#+168
   \   000007F0   38279FE5           LDR      R2,??uip_process_2+0x74  ;; uip_conns
   \   000007F4   912020E0           MLA      R0,R1,R0,R2
   \   000007F8   0050B0E1           MOVS     R5,R0
   \   000007FC   1E0000EA           B        ??uip_process_72
   \                     ??uip_process_71:
   \   00000800   30079FE5           LDR      R0,??uip_process_2+0x7C  ;; c
   \   00000804   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000808   A810A0E3           MOV      R1,#+168
   \   0000080C   1C279FE5           LDR      R2,??uip_process_2+0x74  ;; uip_conns
   \   00000810   912020E0           MLA      R0,R1,R0,R2
   \   00000814   1900D0E5           LDRB     R0,[R0, #+25]
   \   00000818   070050E3           CMP      R0,#+7
   \   0000081C   1000001A           BNE      ??uip_process_73
   \   00000820   000055E3           CMP      R5,#+0
   \   00000824   0800000A           BEQ      ??uip_process_74
   \   00000828   1A00D5E5           LDRB     R0,[R5, #+26]
   \   0000082C   04179FE5           LDR      R1,??uip_process_2+0x7C  ;; c
   \   00000830   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000834   A820A0E3           MOV      R2,#+168
   \   00000838   F0369FE5           LDR      R3,??uip_process_2+0x74  ;; uip_conns
   \   0000083C   923121E0           MLA      R1,R2,R1,R3
   \   00000840   1A10D1E5           LDRB     R1,[R1, #+26]
   \   00000844   010050E1           CMP      R0,R1
   \   00000848   0500002A           BCS      ??uip_process_75
   \                     ??uip_process_74:
   \   0000084C   E4069FE5           LDR      R0,??uip_process_2+0x7C  ;; c
   \   00000850   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000854   A810A0E3           MOV      R1,#+168
   \   00000858   D0269FE5           LDR      R2,??uip_process_2+0x74  ;; uip_conns
   \   0000085C   912020E0           MLA      R0,R1,R0,R2
   \   00000860   0050B0E1           MOVS     R5,R0
   \                     ??uip_process_75:
   \                     ??uip_process_73:
   \   00000864   CC069FE5           LDR      R0,??uip_process_2+0x7C  ;; c
   \   00000868   0000D0E5           LDRB     R0,[R0, #+0]
   \   0000086C   010090E2           ADDS     R0,R0,#+1
   \   00000870   C0169FE5           LDR      R1,??uip_process_2+0x7C  ;; c
   \   00000874   0000C1E5           STRB     R0,[R1, #+0]
   \   00000878   CDFFFFEA           B        ??uip_process_63
   \                     ??uip_process_70:
   \                     ??uip_process_72:
   \   0000087C   000055E3           CMP      R5,#+0
   \   00000880   2E03000A           BEQ      ??uip_process_6
   \                     ??uip_process_76:
   \   00000884   30069FE5           LDR      R0,??uip_process_2  ;; uip_conn
   \   00000888   005080E5           STR      R5,[R0, #+0]
   \   0000088C   0300A0E3           MOV      R0,#+3
   \   00000890   1A00C5E5           STRB     R0,[R5, #+26]
   \   00000894   1800C5E5           STRB     R0,[R5, #+24]
   \   00000898   0000A0E3           MOV      R0,#+0
   \   0000089C   1600C5E5           STRB     R0,[R5, #+22]
   \   000008A0   0400A0E3           MOV      R0,#+4
   \   000008A4   1700C5E5           STRB     R0,[R5, #+23]
   \   000008A8   0000A0E3           MOV      R0,#+0
   \   000008AC   1B00C5E5           STRB     R0,[R5, #+27]
   \   000008B0   6C069FE5           LDR      R0,??uip_process_2+0x68  ;; uip_buf + 36
   \   000008B4   B000D0E1           LDRH     R0,[R0, #+0]
   \   000008B8   B400C5E1           STRH     R0,[R5, #+4]
   \   000008BC   58069FE5           LDR      R0,??uip_process_2+0x60  ;; uip_buf + 34
   \   000008C0   B000D0E1           LDRH     R0,[R0, #+0]
   \   000008C4   B600C5E1           STRH     R0,[R5, #+6]
   \   000008C8   58069FE5           LDR      R0,??uip_process_2+0x6C  ;; uip_buf + 26
   \   000008CC   B000D0E1           LDRH     R0,[R0, #+0]
   \   000008D0   B000C5E1           STRH     R0,[R5, #+0]
   \   000008D4   50069FE5           LDR      R0,??uip_process_2+0x70  ;; uip_buf + 28
   \   000008D8   B000D0E1           LDRH     R0,[R0, #+0]
   \   000008DC   B200C5E1           STRH     R0,[R5, #+2]
   \   000008E0   0100A0E3           MOV      R0,#+1
   \   000008E4   1900C5E5           STRB     R0,[R5, #+25]
   \   000008E8   EC059FE5           LDR      R0,??uip_process_2+0x20  ;; iss
   \   000008EC   0000D0E5           LDRB     R0,[R0, #+0]
   \   000008F0   0C00C5E5           STRB     R0,[R5, #+12]
   \   000008F4   DC059FE5           LDR      R0,??uip_process_2+0x1C  ;; iss + 1
   \   000008F8   0000D0E5           LDRB     R0,[R0, #+0]
   \   000008FC   0D00C5E5           STRB     R0,[R5, #+13]
   \   00000900   CC059FE5           LDR      R0,??uip_process_2+0x18  ;; iss + 2
   \   00000904   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000908   0E00C5E5           STRB     R0,[R5, #+14]
   \   0000090C   BC059FE5           LDR      R0,??uip_process_2+0x14  ;; iss + 3
   \   00000910   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000914   0F00C5E5           STRB     R0,[R5, #+15]
   \   00000918   0100A0E3           MOV      R0,#+1
   \   0000091C   B001C5E1           STRH     R0,[R5, #+16]
   \   00000920   3C0C9FE5           LDR      R0,??uip_process_65+0x4  ;; uip_buf + 41
   \   00000924   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000928   0B00C5E5           STRB     R0,[R5, #+11]
   \   0000092C   380C9FE5           LDR      R0,??uip_process_65+0xC  ;; uip_buf + 40
   \   00000930   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000934   0A00C5E5           STRB     R0,[R5, #+10]
   \   00000938   340C9FE5           LDR      R0,??uip_process_65+0x14  ;; uip_buf + 39
   \   0000093C   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000940   0900C5E5           STRB     R0,[R5, #+9]
   \   00000944   300C9FE5           LDR      R0,??uip_process_65+0x1C  ;; uip_buf + 38
   \   00000948   0000D0E5           LDRB     R0,[R0, #+0]
   \   0000094C   0800C5E5           STRB     R0,[R5, #+8]
   \   00000950   0100A0E3           MOV      R0,#+1
   \   00000954   ........           BL       uip_add_rcv_nxt
   \   00000958   000C9FE5           LDR      R0,??uip_process_65  ;; uip_buf + 46
   \   0000095C   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000960   F00010E2           ANDS     R0,R0,#0xF0
   \   00000964   510050E3           CMP      R0,#+81
   \   00000968   590000BA           BLT      ??uip_process_77
   \   0000096C   C4059FE5           LDR      R0,??uip_process_2+0x7C  ;; c
   \   00000970   0010A0E3           MOV      R1,#+0
   \   00000974   0010C0E5           STRB     R1,[R0, #+0]
   \                     ??uip_process_78:
   \   00000978   B8059FE5           LDR      R0,??uip_process_2+0x7C  ;; c
   \   0000097C   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000980   D81B9FE5           LDR      R1,??uip_process_65  ;; uip_buf + 46
   \   00000984   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000988   FF1011E2           ANDS     R1,R1,#0xFF      ;; Zero extend
   \   0000098C   2112B0E1           LSRS     R1,R1,#+4
   \   00000990   FF1011E2           ANDS     R1,R1,#0xFF      ;; Zero extend
   \   00000994   051051E2           SUBS     R1,R1,#+5
   \   00000998   010150E1           CMP      R0,R1, LSL #+2
   \   0000099C   4C0000AA           BGE      ??uip_process_79
   \   000009A0   90059FE5           LDR      R0,??uip_process_2+0x7C  ;; c
   \   000009A4   0000D0E5           LDRB     R0,[R0, #+0]
   \   000009A8   D41B9FE5           LDR      R1,??uip_process_65+0x24  ;; uip_buf
   \   000009AC   010090E0           ADDS     R0,R0,R1
   \   000009B0   3600D0E5           LDRB     R0,[R0, #+54]
   \   000009B4   CC1B9FE5           LDR      R1,??uip_process_65+0x28  ;; opt
   \   000009B8   0000C1E5           STRB     R0,[R1, #+0]
   \   000009BC   C40B9FE5           LDR      R0,??uip_process_65+0x28  ;; opt
   \   000009C0   0000D0E5           LDRB     R0,[R0, #+0]
   \   000009C4   000050E3           CMP      R0,#+0
   \   000009C8   4100000A           BEQ      ??uip_process_80
   \                     ??uip_process_81:
   \   000009CC   B40B9FE5           LDR      R0,??uip_process_65+0x28  ;; opt
   \   000009D0   0000D0E5           LDRB     R0,[R0, #+0]
   \   000009D4   010050E3           CMP      R0,#+1
   \   000009D8   0500001A           BNE      ??uip_process_82
   \   000009DC   54059FE5           LDR      R0,??uip_process_2+0x7C  ;; c
   \   000009E0   0000D0E5           LDRB     R0,[R0, #+0]
   \   000009E4   010090E2           ADDS     R0,R0,#+1
   \   000009E8   48159FE5           LDR      R1,??uip_process_2+0x7C  ;; c
   \   000009EC   0000C1E5           STRB     R0,[R1, #+0]
   \   000009F0   360000EA           B        ??uip_process_83
   \                     ??uip_process_82:
   \   000009F4   8C0B9FE5           LDR      R0,??uip_process_65+0x28  ;; opt
   \   000009F8   0000D0E5           LDRB     R0,[R0, #+0]
   \   000009FC   020050E3           CMP      R0,#+2
   \   00000A00   2100001A           BNE      ??uip_process_84
   \   00000A04   2C059FE5           LDR      R0,??uip_process_2+0x7C  ;; c
   \   00000A08   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000A0C   701B9FE5           LDR      R1,??uip_process_65+0x24  ;; uip_buf
   \   00000A10   010090E0           ADDS     R0,R0,R1
   \   00000A14   3700D0E5           LDRB     R0,[R0, #+55]
   \   00000A18   040050E3           CMP      R0,#+4
   \   00000A1C   1A00001A           BNE      ??uip_process_84
   \   00000A20   10059FE5           LDR      R0,??uip_process_2+0x7C  ;; c
   \   00000A24   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000A28   541B9FE5           LDR      R1,??uip_process_65+0x24  ;; uip_buf
   \   00000A2C   010090E0           ADDS     R0,R0,R1
   \   00000A30   3800D0E5           LDRB     R0,[R0, #+56]
   \   00000A34   FC149FE5           LDR      R1,??uip_process_2+0x7C  ;; c
   \   00000A38   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000A3C   402B9FE5           LDR      R2,??uip_process_65+0x24  ;; uip_buf
   \   00000A40   021091E0           ADDS     R1,R1,R2
   \   00000A44   3910D1E5           LDRB     R1,[R1, #+57]
   \   00000A48   000491E1           ORRS     R0,R1,R0, LSL #+8
   \   00000A4C   E0149FE5           LDR      R1,??uip_process_2+0x78  ;; tmp16
   \   00000A50   B000C1E1           STRH     R0,[R1, #+0]
   \   00000A54   D8049FE5           LDR      R0,??uip_process_2+0x78  ;; tmp16
   \   00000A58   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000A5C   A710A0E3           MOV      R1,#+167
   \   00000A60   501E81E3           ORR      R1,R1,#0x500
   \   00000A64   010050E1           CMP      R0,R1
   \   00000A68   0200003A           BCC      ??uip_process_85
   \   00000A6C   A600A0E3           MOV      R0,#+166
   \   00000A70   500E80E3           ORR      R0,R0,#0x500
   \   00000A74   010000EA           B        ??uip_process_86
   \                     ??uip_process_85:
   \   00000A78   B4049FE5           LDR      R0,??uip_process_2+0x78  ;; tmp16
   \   00000A7C   B000D0E1           LDRH     R0,[R0, #+0]
   \                     ??uip_process_86:
   \   00000A80   B201C5E1           STRH     R0,[R5, #+18]
   \   00000A84   B401C5E1           STRH     R0,[R5, #+20]
   \   00000A88   110000EA           B        ??uip_process_80
   \                     ??uip_process_84:
   \   00000A8C   A4049FE5           LDR      R0,??uip_process_2+0x7C  ;; c
   \   00000A90   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000A94   E81A9FE5           LDR      R1,??uip_process_65+0x24  ;; uip_buf
   \   00000A98   010090E0           ADDS     R0,R0,R1
   \   00000A9C   3700D0E5           LDRB     R0,[R0, #+55]
   \   00000AA0   000050E3           CMP      R0,#+0
   \   00000AA4   0A00000A           BEQ      ??uip_process_80
   \                     ??uip_process_87:
   \   00000AA8   88049FE5           LDR      R0,??uip_process_2+0x7C  ;; c
   \   00000AAC   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000AB0   80149FE5           LDR      R1,??uip_process_2+0x7C  ;; c
   \   00000AB4   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000AB8   C42A9FE5           LDR      R2,??uip_process_65+0x24  ;; uip_buf
   \   00000ABC   021091E0           ADDS     R1,R1,R2
   \   00000AC0   3710D1E5           LDRB     R1,[R1, #+55]
   \   00000AC4   000091E0           ADDS     R0,R1,R0
   \   00000AC8   68149FE5           LDR      R1,??uip_process_2+0x7C  ;; c
   \   00000ACC   0000C1E5           STRB     R0,[R1, #+0]
   \                     ??uip_process_83:
   \   00000AD0   A8FFFFEA           B        ??uip_process_78
   \                     ??uip_process_79:
   \                     ??uip_process_80:
   \                     ??uip_process_77:
   \                     ??uip_process_26:
   \   00000AD4   0C049FE5           LDR      R0,??uip_process_2+0x2C  ;; uip_buf + 47
   \   00000AD8   1210A0E3           MOV      R1,#+18
   \   00000ADC   0010C0E5           STRB     R1,[R0, #+0]
   \   00000AE0   D8039FE5           LDR      R0,??uip_process_2+0x4  ;; uip_buf + 54
   \   00000AE4   0210A0E3           MOV      R1,#+2
   \   00000AE8   0010C0E5           STRB     R1,[R0, #+0]
   \   00000AEC   980A9FE5           LDR      R0,??uip_process_65+0x2C  ;; uip_buf + 55
   \   00000AF0   0410A0E3           MOV      R1,#+4
   \   00000AF4   0010C0E5           STRB     R1,[R0, #+0]
   \   00000AF8   900A9FE5           LDR      R0,??uip_process_65+0x30  ;; uip_buf + 56
   \   00000AFC   0510A0E3           MOV      R1,#+5
   \   00000B00   0010C0E5           STRB     R1,[R0, #+0]
   \   00000B04   880A9FE5           LDR      R0,??uip_process_65+0x34  ;; uip_buf + 57
   \   00000B08   A610A0E3           MOV      R1,#+166
   \   00000B0C   0010C0E5           STRB     R1,[R0, #+0]
   \   00000B10   C8039FE5           LDR      R0,??uip_process_2+0x24  ;; uip_len
   \   00000B14   2C10A0E3           MOV      R1,#+44
   \   00000B18   B010C0E1           STRH     R1,[R0, #+0]
   \   00000B1C   3C0A9FE5           LDR      R0,??uip_process_65  ;; uip_buf + 46
   \   00000B20   6010A0E3           MOV      R1,#+96
   \   00000B24   0010C0E5           STRB     R1,[R0, #+0]
   \   00000B28   0A0200EA           B        ??uip_process_88
   1429              uip_connr->tcpstateflags = UIP_CLOSED;
   \                     ??uip_process_56:
   \   00000B2C   0000A0E3           MOV      R0,#+0
   \   00000B30   1900C5E5           STRB     R0,[R5, #+25]
   1430              UIP_LOG("tcp: got reset, aborting connection.");
   1431              uip_flags = UIP_ABORT;
   \   00000B34   90039FE5           LDR      R0,??uip_process_2+0x10  ;; uip_flags
   \   00000B38   2010A0E3           MOV      R1,#+32
   \   00000B3C   0010C0E5           STRB     R1,[R0, #+0]
   1432              UIP_APPCALL();
   \   00000B40   ........           BL       telnetd_appcall
   1433              goto drop;
   \   00000B44   7D0200EA           B        ??uip_process_6
   1434            }
   1435            /* Calculated the length of the data, if the application has sent
   1436               any data to us. */
   1437            c = (BUF->tcpoffset >> 4) << 2;
   \                     ??uip_process_57:
   \   00000B48   100A9FE5           LDR      R0,??uip_process_65  ;; uip_buf + 46
   \   00000B4C   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000B50   FF0010E2           ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000B54   2002B0E1           LSRS     R0,R0,#+4
   \   00000B58   0001B0E1           LSLS     R0,R0,#+2
   \   00000B5C   D4139FE5           LDR      R1,??uip_process_2+0x7C  ;; c
   \   00000B60   0000C1E5           STRB     R0,[R1, #+0]
   1438            /* uip_len will contain the length of the actual TCP data. This is
   1439               calculated by subtracing the length of the TCP header (in
   1440               c) and the length of the IP header (20 bytes). */
   1441            uip_len = uip_len - c - UIP_IPH_LEN;
   \   00000B64   74039FE5           LDR      R0,??uip_process_2+0x24  ;; uip_len
   \   00000B68   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000B6C   C4139FE5           LDR      R1,??uip_process_2+0x7C  ;; c
   \   00000B70   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000B74   010050E0           SUBS     R0,R0,R1
   \   00000B78   140050E2           SUBS     R0,R0,#+20
   \   00000B7C   5C139FE5           LDR      R1,??uip_process_2+0x24  ;; uip_len
   \   00000B80   B000C1E1           STRH     R0,[R1, #+0]
   1442          
   1443            /* First, check if the sequence number of the incoming packet is
   1444               what we're expecting next. If not, we send out an ACK with the
   1445               correct numbers in. */
   1446            if(!(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
   1447                 ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)))) {
   \   00000B84   1900D5E5           LDRB     R0,[R5, #+25]
   \   00000B88   0F0010E2           ANDS     R0,R0,#0xF
   \   00000B8C   020050E3           CMP      R0,#+2
   \   00000B90   0400001A           BNE      ??uip_process_89
   \   00000B94   4C039FE5           LDR      R0,??uip_process_2+0x2C  ;; uip_buf + 47
   \   00000B98   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000B9C   3F0010E2           ANDS     R0,R0,#0x3F
   \   00000BA0   120050E3           CMP      R0,#+18
   \   00000BA4   1C00000A           BEQ      ??uip_process_90
   1448              if((uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
   1449                 (BUF->seqno[0] != uip_connr->rcv_nxt[0] ||
   1450          	BUF->seqno[1] != uip_connr->rcv_nxt[1] ||
   1451          	BUF->seqno[2] != uip_connr->rcv_nxt[2] ||
   1452          	BUF->seqno[3] != uip_connr->rcv_nxt[3])) {
   \                     ??uip_process_89:
   \   00000BA8   30039FE5           LDR      R0,??uip_process_2+0x24  ;; uip_len
   \   00000BAC   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000BB0   010050E3           CMP      R0,#+1
   \   00000BB4   0300002A           BCS      ??uip_process_91
   \   00000BB8   28039FE5           LDR      R0,??uip_process_2+0x2C  ;; uip_buf + 47
   \   00000BBC   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000BC0   030010E3           TST      R0,#0x3
   \   00000BC4   1400000A           BEQ      ??uip_process_92
   \                     ??uip_process_91:
   \   00000BC8   AC099FE5           LDR      R0,??uip_process_65+0x1C  ;; uip_buf + 38
   \   00000BCC   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000BD0   0810D5E5           LDRB     R1,[R5, #+8]
   \   00000BD4   010050E1           CMP      R0,R1
   \   00000BD8   0E00001A           BNE      ??uip_process_93
   \   00000BDC   90099FE5           LDR      R0,??uip_process_65+0x14  ;; uip_buf + 39
   \   00000BE0   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000BE4   0910D5E5           LDRB     R1,[R5, #+9]
   \   00000BE8   010050E1           CMP      R0,R1
   \   00000BEC   0900001A           BNE      ??uip_process_93
   \   00000BF0   74099FE5           LDR      R0,??uip_process_65+0xC  ;; uip_buf + 40
   \   00000BF4   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000BF8   0A10D5E5           LDRB     R1,[R5, #+10]
   \   00000BFC   010050E1           CMP      R0,R1
   \   00000C00   0400001A           BNE      ??uip_process_93
   \   00000C04   58099FE5           LDR      R0,??uip_process_65+0x4  ;; uip_buf + 41
   \   00000C08   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000C0C   0B10D5E5           LDRB     R1,[R5, #+11]
   \   00000C10   010050E1           CMP      R0,R1
   \   00000C14   0000000A           BEQ      ??uip_process_92
   1453                goto tcp_send_ack;
   \                     ??uip_process_93:
   \   00000C18   C50100EA           B        ??uip_process_94
   1454              }
   1455            }
   1456          
   1457            /* Next, check if the incoming segment acknowledges any outstanding
   1458               data. If so, we update the sequence number, reset the length of
   1459               the outstanding data, calculate RTT estimations, and reset the
   1460               retransmission timer. */
   1461            if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
   \                     ??uip_process_92:
   \                     ??uip_process_90:
   \   00000C1C   C4029FE5           LDR      R0,??uip_process_2+0x2C  ;; uip_buf + 47
   \   00000C20   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000C24   100010E3           TST      R0,#0x10
   \   00000C28   4F00000A           BEQ      ??uip_process_95
   \   00000C2C   B001D5E1           LDRH     R0,[R5, #+16]
   \   00000C30   000050E3           CMP      R0,#+0
   \   00000C34   4C00000A           BEQ      ??uip_process_95
   1462              uip_add32(uip_connr->snd_nxt, uip_connr->len);
   \   00000C38   B011D5E1           LDRH     R1,[R5, #+16]
   \   00000C3C   0C0095E2           ADDS     R0,R5,#+12
   \   00000C40   ........           BL       uip_add32
   1463          
   1464              if(BUF->ackno[0] == uip_acc32[0] &&
   1465                 BUF->ackno[1] == uip_acc32[1] &&
   1466                 BUF->ackno[2] == uip_acc32[2] &&
   1467                 BUF->ackno[3] == uip_acc32[3]) {
   \   00000C44   34099FE5           LDR      R0,??uip_process_65+0x20  ;; uip_buf + 42
   \   00000C48   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000C4C   44199FE5           LDR      R1,??uip_process_65+0x38  ;; uip_acc32
   \   00000C50   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000C54   010050E1           CMP      R0,R1
   \   00000C58   4300001A           BNE      ??uip_process_96
   \   00000C5C   14099FE5           LDR      R0,??uip_process_65+0x18  ;; uip_buf + 43
   \   00000C60   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000C64   30199FE5           LDR      R1,??uip_process_65+0x3C  ;; uip_acc32 + 1
   \   00000C68   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000C6C   010050E1           CMP      R0,R1
   \   00000C70   3D00001A           BNE      ??uip_process_96
   \   00000C74   F4089FE5           LDR      R0,??uip_process_65+0x10  ;; uip_buf + 44
   \   00000C78   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000C7C   1C199FE5           LDR      R1,??uip_process_65+0x40  ;; uip_acc32 + 2
   \   00000C80   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000C84   010050E1           CMP      R0,R1
   \   00000C88   3700001A           BNE      ??uip_process_96
   \   00000C8C   D4089FE5           LDR      R0,??uip_process_65+0x8  ;; uip_buf + 45
   \   00000C90   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000C94   08199FE5           LDR      R1,??uip_process_65+0x44  ;; uip_acc32 + 3
   \   00000C98   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000C9C   010050E1           CMP      R0,R1
   \   00000CA0   3100001A           BNE      ??uip_process_96
   1468                /* Update sequence number. */
   1469                uip_connr->snd_nxt[0] = uip_acc32[0];
   \   00000CA4   EC089FE5           LDR      R0,??uip_process_65+0x38  ;; uip_acc32
   \   00000CA8   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000CAC   0C00C5E5           STRB     R0,[R5, #+12]
   1470                uip_connr->snd_nxt[1] = uip_acc32[1];
   \   00000CB0   E4089FE5           LDR      R0,??uip_process_65+0x3C  ;; uip_acc32 + 1
   \   00000CB4   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000CB8   0D00C5E5           STRB     R0,[R5, #+13]
   1471                uip_connr->snd_nxt[2] = uip_acc32[2];
   \   00000CBC   DC089FE5           LDR      R0,??uip_process_65+0x40  ;; uip_acc32 + 2
   \   00000CC0   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000CC4   0E00C5E5           STRB     R0,[R5, #+14]
   1472                uip_connr->snd_nxt[3] = uip_acc32[3];
   \   00000CC8   D4089FE5           LDR      R0,??uip_process_65+0x44  ;; uip_acc32 + 3
   \   00000CCC   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000CD0   0F00C5E5           STRB     R0,[R5, #+15]
   1473          	
   1474          
   1475                /* Do RTT estimation, unless we have done retransmissions. */
   1476                if(uip_connr->nrtx == 0) {
   \   00000CD4   1B00D5E5           LDRB     R0,[R5, #+27]
   \   00000CD8   000050E3           CMP      R0,#+0
   \   00000CDC   1B00001A           BNE      ??uip_process_97
   1477          	signed char m;
   1478          	m = uip_connr->rto - uip_connr->timer;
   \   00000CE0   D811D5E1           LDRSB    R1,[R5, #+24]
   \   00000CE4   DA21D5E1           LDRSB    R2,[R5, #+26]
   \   00000CE8   021051E0           SUBS     R1,R1,R2
   \   00000CEC   0100B0E1           MOVS     R0,R1
   1479          	/* This is taken directly from VJs original code in his paper */
   1480          	m = m - (uip_connr->sa >> 3);
   \   00000CF0   1610D5E5           LDRB     R1,[R5, #+22]
   \   00000CF4   FF1011E2           ANDS     R1,R1,#0xFF      ;; Zero extend
   \   00000CF8   A10150E0           SUBS     R0,R0,R1, LSR #+3
   1481          	uip_connr->sa += m;
   \   00000CFC   1610D5E5           LDRB     R1,[R5, #+22]
   \   00000D00   011090E0           ADDS     R1,R0,R1
   \   00000D04   1610C5E5           STRB     R1,[R5, #+22]
   1482          	if(m < 0) {
   \   00000D08   000CA0E1           MOV      R0,R0, LSL #+24
   \   00000D0C   400CB0E1           MOVS     R0,R0, ASR #+24
   \   00000D10   000050E3           CMP      R0,#+0
   \   00000D14   0200005A           BPL      ??uip_process_98
   1483          	  m = -m;
   \   00000D18   000CA0E1           MOV      R0,R0, LSL #+24
   \   00000D1C   400CB0E1           MOVS     R0,R0, ASR #+24
   \   00000D20   000070E2           RSBS     R0,R0,#+0
   1484          	}
   1485          	m = m - (uip_connr->sv >> 2);
   \                     ??uip_process_98:
   \   00000D24   1710D5E5           LDRB     R1,[R5, #+23]
   \   00000D28   FF1011E2           ANDS     R1,R1,#0xFF      ;; Zero extend
   \   00000D2C   210150E0           SUBS     R0,R0,R1, LSR #+2
   1486          	uip_connr->sv += m;
   \   00000D30   1710D5E5           LDRB     R1,[R5, #+23]
   \   00000D34   011090E0           ADDS     R1,R0,R1
   \   00000D38   1710C5E5           STRB     R1,[R5, #+23]
   1487          	uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;
   \   00000D3C   1610D5E5           LDRB     R1,[R5, #+22]
   \   00000D40   FF1011E2           ANDS     R1,R1,#0xFF      ;; Zero extend
   \   00000D44   1720D5E5           LDRB     R2,[R5, #+23]
   \   00000D48   A11192E0           ADDS     R1,R2,R1, LSR #+3
   \   00000D4C   1810C5E5           STRB     R1,[R5, #+24]
   1488          
   1489                }
   1490                /* Set the acknowledged flag. */
   1491                uip_flags = UIP_ACKDATA;
   \                     ??uip_process_97:
   \   00000D50   74019FE5           LDR      R0,??uip_process_2+0x10  ;; uip_flags
   \   00000D54   0110A0E3           MOV      R1,#+1
   \   00000D58   0010C0E5           STRB     R1,[R0, #+0]
   1492                /* Reset the retransmission timer. */
   1493                uip_connr->timer = uip_connr->rto;
   \   00000D5C   1800D5E5           LDRB     R0,[R5, #+24]
   \   00000D60   1A00C5E5           STRB     R0,[R5, #+26]
   1494          
   1495                /* Reset length of outstanding data. */
   1496                uip_connr->len = 0;
   \   00000D64   0000A0E3           MOV      R0,#+0
   \   00000D68   B001C5E1           STRH     R0,[R5, #+16]
   1497              }
   1498          
   1499            }
   1500          
   1501            /* Do different things depending on in what state the connection is. */
   1502            switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
   \                     ??uip_process_96:
   \                     ??uip_process_95:
   \   00000D6C   1900D5E5           LDRB     R0,[R5, #+25]
   \   00000D70   0F0010E2           ANDS     R0,R0,#0xF
   \   00000D74   FF0010E2           ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000D78   010040E2           SUB      R0,R0,#+1
   \   00000D7C   070050E3           CMP      R0,#+7
   \   00000D80   6A01008A           BHI      ??uip_process_99
   \   00000D84   08108FE2           ADR      R1,??uip_process_1
   \   00000D88   8000A0E1           MOV      R0,R0, LSL #+1
   \   00000D8C   B01091E1           LDRH     R1,[R1, R0]
   \   00000D90   01F18FE0           ADD      PC,PC,R1, LSL #+2
   \                     ??uip_process_1:
   \   00000D94   030066012000       DC16     +3,+358,+32,+277
   \              1501        
   \   00000D9C   42015E015D01       DC16     +322,+350,+349,+266
   \              0A01        
   1503              /* CLOSED and LISTEN are not handled here. CLOSE_WAIT is not
   1504          	implemented, since we force the application to close when the
   1505          	peer sends a FIN (hence the application goes directly from
   1506          	ESTABLISHED to LAST_ACK). */
   1507            case UIP_SYN_RCVD:
   1508              /* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
   1509                 we are waiting for an ACK that acknowledges the data we sent
   1510                 out the last time. Therefore, we want to have the UIP_ACKDATA
   1511                 flag set. If so, we enter the ESTABLISHED state. */
   1512              if(uip_flags & UIP_ACKDATA) {
   \                     ??uip_process_100:
   \   00000DA4   20019FE5           LDR      R0,??uip_process_2+0x10  ;; uip_flags
   \   00000DA8   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000DAC   010010E3           TST      R0,#0x1
   \   00000DB0   1700000A           BEQ      ??uip_process_101
   1513                uip_connr->tcpstateflags = UIP_ESTABLISHED;
   \   00000DB4   0300A0E3           MOV      R0,#+3
   \   00000DB8   1900C5E5           STRB     R0,[R5, #+25]
   1514                uip_flags = UIP_CONNECTED;
   \   00000DBC   08019FE5           LDR      R0,??uip_process_2+0x10  ;; uip_flags
   \   00000DC0   4010A0E3           MOV      R1,#+64
   \   00000DC4   0010C0E5           STRB     R1,[R0, #+0]
   1515                uip_connr->len = 0;
   \   00000DC8   0000A0E3           MOV      R0,#+0
   \   00000DCC   B001C5E1           STRH     R0,[R5, #+16]
   1516                if(uip_len > 0) {
   \   00000DD0   08019FE5           LDR      R0,??uip_process_2+0x24  ;; uip_len
   \   00000DD4   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000DD8   010050E3           CMP      R0,#+1
   \   00000DDC   0700003A           BCC      ??uip_process_102
   1517                  uip_flags |= UIP_NEWDATA;
   \   00000DE0   E4009FE5           LDR      R0,??uip_process_2+0x10  ;; uip_flags
   \   00000DE4   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000DE8   020090E3           ORRS     R0,R0,#0x2
   \   00000DEC   D8109FE5           LDR      R1,??uip_process_2+0x10  ;; uip_flags
   \   00000DF0   0000C1E5           STRB     R0,[R1, #+0]
   1518                  uip_add_rcv_nxt(uip_len);
   \   00000DF4   E4009FE5           LDR      R0,??uip_process_2+0x24  ;; uip_len
   \   00000DF8   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000DFC   ........           BL       uip_add_rcv_nxt
   1519                }
   1520                uip_slen = 0;
   \                     ??uip_process_102:
   \   00000E00   DC009FE5           LDR      R0,??uip_process_2+0x28  ;; uip_slen
   \   00000E04   0010A0E3           MOV      R1,#+0
   \   00000E08   B010C0E1           STRH     R1,[R0, #+0]
   1521                UIP_APPCALL();
   \   00000E0C   ........           BL       telnetd_appcall
   1522                goto appsend;
   \   00000E10   8F0000EA           B        ??uip_process_5
   1523              }
   1524              goto drop;
   \                     ??uip_process_101:
   \   00000E14   C90100EA           B        ??uip_process_6
   1525          #if UIP_ACTIVE_OPEN
   1526            case UIP_SYN_SENT:
   1527              /* In SYN_SENT, we wait for a SYNACK that is sent in response to
   1528                 our SYN. The rcv_nxt is set to sequence number in the SYNACK
   1529                 plus one, and we send an ACK. We move into the ESTABLISHED
   1530                 state. */
   1531              if((uip_flags & UIP_ACKDATA) &&
   1532                 (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {
   1533          
   1534                /* Parse the TCP MSS option, if present. */
   1535                if((BUF->tcpoffset & 0xf0) > 0x50) {
   1536          	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
   1537          	  opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
   1538          	  if(opt == TCP_OPT_END) {
   1539          	    /* End of options. */
   1540          	    break;
   1541          	  } else if(opt == TCP_OPT_NOOP) {
   1542          	    ++c;
   1543          	    /* NOP option. */
   1544          	  } else if(opt == TCP_OPT_MSS &&
   1545          		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
   1546          	    /* An MSS option with the right option length. */
   1547          	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
   1548          	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
   1549          	    uip_connr->initialmss =
   1550          	      uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
   1551          
   1552          	    /* And we are done processing options. */
   1553          	    break;
   1554          	  } else {
   1555          	    /* All other options have a length field, so that we easily
   1556          	       can skip past them. */
   1557          	    if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
   1558          	      /* If the length field is zero, the options are malformed
   1559          		 and we don't process them further. */
   1560          	      break;
   1561          	    }
   1562          	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
   1563          	  }
   1564          	}
   1565                }
   1566                uip_connr->tcpstateflags = UIP_ESTABLISHED;
   1567                uip_connr->rcv_nxt[0] = BUF->seqno[0];
   1568                uip_connr->rcv_nxt[1] = BUF->seqno[1];
   1569                uip_connr->rcv_nxt[2] = BUF->seqno[2];
   1570                uip_connr->rcv_nxt[3] = BUF->seqno[3];
   1571                uip_add_rcv_nxt(1);
   1572                uip_flags = UIP_CONNECTED | UIP_NEWDATA;
   1573                uip_connr->len = 0;
   1574                uip_len = 0;
   1575                uip_slen = 0;
   1576                UIP_APPCALL();
   1577                goto appsend;
   1578              }
   1579              /* Inform the application that the connection failed */
   1580              uip_flags = UIP_ABORT;
   1581              UIP_APPCALL();
   1582              /* The connection is closed after we send the RST */
   1583              uip_conn->tcpstateflags = UIP_CLOSED;
   1584              goto reset;
   1585          #endif /* UIP_ACTIVE_OPEN */
   1586          
   1587            case UIP_ESTABLISHED:
   1588              /* In the ESTABLISHED state, we call upon the application to feed
   1589              data into the uip_buf. If the UIP_ACKDATA flag is set, the
   1590              application should put new data into the buffer, otherwise we are
   1591              retransmitting an old segment, and the application should put that
   1592              data into the buffer.
   1593          
   1594              If the incoming packet is a FIN, we should close the connection on
   1595              this side as well, and we send out a FIN and enter the LAST_ACK
   1596              state. We require that there is no outstanding data; otherwise the
   1597              sequence numbers will be screwed up. */
   1598          
   1599              if(BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
   \                     ??uip_process_103:
   \   00000E18   C8009FE5           LDR      R0,??uip_process_2+0x2C  ;; uip_buf + 47
   \   00000E1C   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000E20   010010E3           TST      R0,#0x1
   \   00000E24   4500000A           BEQ      ??uip_process_104
   \   00000E28   1900D5E5           LDRB     R0,[R5, #+25]
   \   00000E2C   100010E3           TST      R0,#0x10
   \   00000E30   4200001A           BNE      ??uip_process_104
   1600                if(uip_outstanding(uip_connr)) {
   \   00000E34   B001D5E1           LDRH     R0,[R5, #+16]
   \   00000E38   000050E3           CMP      R0,#+0
   \   00000E3C   BF01001A           BNE      ??uip_process_6
   1601          	goto drop;
   1602                }
   1603                uip_add_rcv_nxt(1 + uip_len);
   \                     ??uip_process_105:
   \   00000E40   98009FE5           LDR      R0,??uip_process_2+0x24  ;; uip_len
   \   00000E44   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000E48   010090E2           ADDS     R0,R0,#+1
   \   00000E4C   0008A0E1           MOV      R0,R0, LSL #+16
   \   00000E50   2008B0E1           MOVS     R0,R0, LSR #+16
   \   00000E54   ........           BL       uip_add_rcv_nxt
   1604                uip_flags |= UIP_CLOSE;
   \   00000E58   6C009FE5           LDR      R0,??uip_process_2+0x10  ;; uip_flags
   \   00000E5C   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000E60   100090E3           ORRS     R0,R0,#0x10
   \   00000E64   60109FE5           LDR      R1,??uip_process_2+0x10  ;; uip_flags
   \   00000E68   0000C1E5           STRB     R0,[R1, #+0]
   1605                if(uip_len > 0) {
   \   00000E6C   6C009FE5           LDR      R0,??uip_process_2+0x24  ;; uip_len
   \   00000E70   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000E74   010050E3           CMP      R0,#+1
   \   00000E78   0400003A           BCC      ??uip_process_106
   1606          	uip_flags |= UIP_NEWDATA;
   \   00000E7C   48009FE5           LDR      R0,??uip_process_2+0x10  ;; uip_flags
   \   00000E80   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000E84   020090E3           ORRS     R0,R0,#0x2
   \   00000E88   3C109FE5           LDR      R1,??uip_process_2+0x10  ;; uip_flags
   \   00000E8C   0000C1E5           STRB     R0,[R1, #+0]
   1607                }
   1608                UIP_APPCALL();
   \                     ??uip_process_106:
   \   00000E90   ........           BL       telnetd_appcall
   1609                uip_connr->len = 1;
   \   00000E94   0100A0E3           MOV      R0,#+1
   \   00000E98   B001C5E1           STRH     R0,[R5, #+16]
   1610                uip_connr->tcpstateflags = UIP_LAST_ACK;
   \   00000E9C   0800A0E3           MOV      R0,#+8
   \   00000EA0   1900C5E5           STRB     R0,[R5, #+25]
   1611                uip_connr->nrtx = 0;
   \   00000EA4   0000A0E3           MOV      R0,#+0
   \   00000EA8   1B00C5E5           STRB     R0,[R5, #+27]
   1612              tcp_send_finack:
   1613                BUF->flags = TCP_FIN | TCP_ACK;
   \                     ??uip_process_30:
   \   00000EAC   34009FE5           LDR      R0,??uip_process_2+0x2C  ;; uip_buf + 47
   \   00000EB0   1110A0E3           MOV      R1,#+17
   \   00000EB4   0010C0E5           STRB     R1,[R0, #+0]
   1614                goto tcp_send_nodata;
   \   00000EB8   200100EA           B        ??uip_process_21
   \                     ??uip_process_2:
   \   00000EBC   ........           DC32     uip_conn
   \   00000EC0   ........           DC32     uip_buf + 54
   \   00000EC4   ........           DC32     uip_appdata
   \   00000EC8   ........           DC32     uip_sappdata
   \   00000ECC   ........           DC32     uip_flags
   \   00000ED0   ........           DC32     iss + 3
   \   00000ED4   ........           DC32     iss + 2
   \   00000ED8   ........           DC32     iss + 1
   \   00000EDC   ........           DC32     iss
   \   00000EE0   ........           DC32     uip_len
   \   00000EE4   ........           DC32     uip_slen
   \   00000EE8   ........           DC32     uip_buf + 47
   \   00000EEC   ........           DC32     uip_buf + 14
   \   00000EF0   ........           DC32     uip_buf + 16
   \   00000EF4   ........           DC32     uip_buf + 17
   \   00000EF8   ........           DC32     uip_buf + 20
   \   00000EFC   ........           DC32     uip_buf + 21
   \   00000F00   ........           DC32     uip_hostaddr
   \   00000F04   ........           DC32     all_zeroes_addr
   \   00000F08   ........           DC32     uip_hostaddr + 2
   \   00000F0C   ........           DC32     all_zeroes_addr + 2
   \   00000F10   ........           DC32     uip_buf + 30
   \   00000F14   ........           DC32     uip_buf + 32
   \   00000F18   ........           DC32     uip_buf + 23
   \   00000F1C   ........           DC32     uip_buf + 34
   \   00000F20   ........           DC32     ping_flag
   \   00000F24   ........           DC32     uip_buf + 36
   \   00000F28   ........           DC32     uip_buf + 26
   \   00000F2C   ........           DC32     uip_buf + 28
   \   00000F30   ........           DC32     uip_conns
   \   00000F34   ........           DC32     tmp16
   \   00000F38   ........           DC32     c
   \   00000F3C   ........           DC32     uip_listenports
   1615              }
   1616          
   1617              /* Check the URG flag. If this is set, the segment carries urgent
   1618                 data that we must pass to the application. */
   1619              if((BUF->flags & TCP_URG) != 0) {
   \                     ??uip_process_104:
   \   00000F40   60069FE5           LDR      R0,??uip_process_65+0x48  ;; uip_buf + 47
   \   00000F44   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000F48   200010E3           TST      R0,#0x20
   \   00000F4C   1300000A           BEQ      ??uip_process_107
   1620          //#if UIP_URGDATA > 0
   1621          //      uip_urglen = (BUF->urgp[0] << 8) | BUF->urgp[1];
   1622          //      if(uip_urglen > uip_len) {
   1623          //	/* There is more urgent data in the next segment to come. */
   1624          //	uip_urglen = uip_len;
   1625          //      }
   1626          //      uip_add_rcv_nxt(uip_urglen);
   1627          //      uip_len -= uip_urglen;
   1628          //      uip_urgdata = uip_appdata;
   1629          //      uip_appdata += uip_urglen;
   1630          //    } else {
   1631          //      uip_urglen = 0;
   1632          //#else /* UIP_URGDATA > 0 */
   1633                uip_appdata = ((char *)uip_appdata) + ((BUF->urgp[0] << 8) | BUF->urgp[1]);
   \   00000F50   54069FE5           LDR      R0,??uip_process_65+0x4C  ;; uip_buf + 52
   \   00000F54   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000F58   50169FE5           LDR      R1,??uip_process_65+0x50  ;; uip_buf + 53
   \   00000F5C   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000F60   000491E1           ORRS     R0,R1,R0, LSL #+8
   \   00000F64   48169FE5           LDR      R1,??uip_process_65+0x54  ;; uip_appdata
   \   00000F68   001091E5           LDR      R1,[R1, #+0]
   \   00000F6C   010090E0           ADDS     R0,R0,R1
   \   00000F70   3C169FE5           LDR      R1,??uip_process_65+0x54  ;; uip_appdata
   \   00000F74   000081E5           STR      R0,[R1, #+0]
   1634                uip_len -= (BUF->urgp[0] << 8) | BUF->urgp[1];
   \   00000F78   38069FE5           LDR      R0,??uip_process_65+0x58  ;; uip_len
   \   00000F7C   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000F80   24169FE5           LDR      R1,??uip_process_65+0x4C  ;; uip_buf + 52
   \   00000F84   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000F88   20269FE5           LDR      R2,??uip_process_65+0x50  ;; uip_buf + 53
   \   00000F8C   0020D2E5           LDRB     R2,[R2, #+0]
   \   00000F90   011492E1           ORRS     R1,R2,R1, LSL #+8
   \   00000F94   010050E0           SUBS     R0,R0,R1
   \   00000F98   18169FE5           LDR      R1,??uip_process_65+0x58  ;; uip_len
   \   00000F9C   B000C1E1           STRH     R0,[R1, #+0]
   1635          //#endif /* UIP_URGDATA > 0 */
   1636              }
   1637          
   1638              /* If uip_len > 0 we have TCP data in the packet, and we flag this
   1639                 by setting the UIP_NEWDATA flag and update the sequence number
   1640                 we acknowledge. If the application has stopped the dataflow
   1641                 using uip_stop(), we must not accept any data packets from the
   1642                 remote host. */
   1643              if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
   \                     ??uip_process_107:
   \   00000FA0   10069FE5           LDR      R0,??uip_process_65+0x58  ;; uip_len
   \   00000FA4   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000FA8   010050E3           CMP      R0,#+1
   \   00000FAC   0A00003A           BCC      ??uip_process_108
   \   00000FB0   1900D5E5           LDRB     R0,[R5, #+25]
   \   00000FB4   100010E3           TST      R0,#0x10
   \   00000FB8   0700001A           BNE      ??uip_process_108
   1644                uip_flags |= UIP_NEWDATA;
   \   00000FBC   F8059FE5           LDR      R0,??uip_process_65+0x5C  ;; uip_flags
   \   00000FC0   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000FC4   020090E3           ORRS     R0,R0,#0x2
   \   00000FC8   EC159FE5           LDR      R1,??uip_process_65+0x5C  ;; uip_flags
   \   00000FCC   0000C1E5           STRB     R0,[R1, #+0]
   1645                uip_add_rcv_nxt(uip_len);
   \   00000FD0   E0059FE5           LDR      R0,??uip_process_65+0x58  ;; uip_len
   \   00000FD4   B000D0E1           LDRH     R0,[R0, #+0]
   \   00000FD8   ........           BL       uip_add_rcv_nxt
   1646              }
   1647          
   1648              /* Check if the available buffer space advertised by the other end
   1649                 is smaller than the initial MSS for this connection. If so, we
   1650                 set the current MSS to the window size to ensure that the
   1651                 application does not send more data than the other end can
   1652                 handle.
   1653          
   1654                 If the remote host advertises a zero window, we set the MSS to
   1655                 the initial MSS so that the application will send an entire MSS
   1656                 of data. This data will not be acknowledged by the receiver,
   1657                 and the application will retransmit it. This is called the
   1658                 "persistent timer" and uses the retransmission mechanim.
   1659              */
   1660              tmp16 = ((u16_t)BUF->wnd[0] << 8) + (u16_t)BUF->wnd[1];
   \                     ??uip_process_108:
   \   00000FDC   DC059FE5           LDR      R0,??uip_process_65+0x60  ;; uip_buf + 48
   \   00000FE0   0000D0E5           LDRB     R0,[R0, #+0]
   \   00000FE4   D8159FE5           LDR      R1,??uip_process_65+0x64  ;; uip_buf + 49
   \   00000FE8   0010D1E5           LDRB     R1,[R1, #+0]
   \   00000FEC   000491E0           ADDS     R0,R1,R0, LSL #+8
   \   00000FF0   D0159FE5           LDR      R1,??uip_process_65+0x68  ;; tmp16
   \   00000FF4   B000C1E1           STRH     R0,[R1, #+0]
   1661              if(tmp16 > uip_connr->initialmss ||
   1662                 tmp16 == 0) {
   \   00000FF8   B401D5E1           LDRH     R0,[R5, #+20]
   \   00000FFC   C4159FE5           LDR      R1,??uip_process_65+0x68  ;; tmp16
   \   00001000   B010D1E1           LDRH     R1,[R1, #+0]
   \   00001004   010050E1           CMP      R0,R1
   \   00001008   0300003A           BCC      ??uip_process_109
   \   0000100C   B4059FE5           LDR      R0,??uip_process_65+0x68  ;; tmp16
   \   00001010   B000D0E1           LDRH     R0,[R0, #+0]
   \   00001014   000050E3           CMP      R0,#+0
   \   00001018   0200001A           BNE      ??uip_process_110
   1663                tmp16 = uip_connr->initialmss;
   \                     ??uip_process_109:
   \   0000101C   B401D5E1           LDRH     R0,[R5, #+20]
   \   00001020   A0159FE5           LDR      R1,??uip_process_65+0x68  ;; tmp16
   \   00001024   B000C1E1           STRH     R0,[R1, #+0]
   1664              }
   1665              uip_connr->mss = tmp16;
   \                     ??uip_process_110:
   \   00001028   98059FE5           LDR      R0,??uip_process_65+0x68  ;; tmp16
   \   0000102C   B000D0E1           LDRH     R0,[R0, #+0]
   \   00001030   B201C5E1           STRH     R0,[R5, #+18]
   1666          
   1667              /* If this packet constitutes an ACK for outstanding data (flagged
   1668                 by the UIP_ACKDATA flag, we should call the application since it
   1669                 might want to send more data. If the incoming packet had data
   1670                 from the peer (as flagged by the UIP_NEWDATA flag), the
   1671                 application must also be notified.
   1672          
   1673                 When the application is called, the global variable uip_len
   1674                 contains the length of the incoming data. The application can
   1675                 access the incoming data through the global pointer
   1676                 uip_appdata, which usually points UIP_IPTCPH_LEN + UIP_LLH_LEN
   1677                 bytes into the uip_buf array.
   1678          
   1679                 If the application wishes to send any data, this data should be
   1680                 put into the uip_appdata and the length of the data should be
   1681                 put into uip_len. If the application don't have any data to
   1682                 send, uip_len must be set to 0. */
   1683              if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {
   \   00001034   80059FE5           LDR      R0,??uip_process_65+0x5C  ;; uip_flags
   \   00001038   0000D0E5           LDRB     R0,[R0, #+0]
   \   0000103C   030010E3           TST      R0,#0x3
   \   00001040   5D00000A           BEQ      ??uip_process_111
   1684                uip_slen = 0;
   \   00001044   80059FE5           LDR      R0,??uip_process_65+0x6C  ;; uip_slen
   \   00001048   0010A0E3           MOV      R1,#+0
   \   0000104C   B010C0E1           STRH     R1,[R0, #+0]
   1685                UIP_APPCALL();
   \   00001050   ........           BL       telnetd_appcall
   1686          
   1687              appsend:
   1688          
   1689                if(uip_flags & UIP_ABORT) {
   \                     ??uip_process_5:
   \   00001054   60059FE5           LDR      R0,??uip_process_65+0x5C  ;; uip_flags
   \   00001058   0000D0E5           LDRB     R0,[R0, #+0]
   \   0000105C   200010E3           TST      R0,#0x20
   \   00001060   0800000A           BEQ      ??uip_process_112
   1690          	uip_slen = 0;
   \   00001064   60059FE5           LDR      R0,??uip_process_65+0x6C  ;; uip_slen
   \   00001068   0010A0E3           MOV      R1,#+0
   \   0000106C   B010C0E1           STRH     R1,[R0, #+0]
   1691          	uip_connr->tcpstateflags = UIP_CLOSED;
   \   00001070   0000A0E3           MOV      R0,#+0
   \   00001074   1900C5E5           STRB     R0,[R5, #+25]
   1692          	BUF->flags = TCP_RST | TCP_ACK;
   \   00001078   28059FE5           LDR      R0,??uip_process_65+0x48  ;; uip_buf + 47
   \   0000107C   1410A0E3           MOV      R1,#+20
   \   00001080   0010C0E5           STRB     R1,[R0, #+0]
   1693          	goto tcp_send_nodata;
   \   00001084   AD0000EA           B        ??uip_process_21
   1694                }
   1695          
   1696                if(uip_flags & UIP_CLOSE) {
   \                     ??uip_process_112:
   \   00001088   2C059FE5           LDR      R0,??uip_process_65+0x5C  ;; uip_flags
   \   0000108C   0000D0E5           LDRB     R0,[R0, #+0]
   \   00001090   100010E3           TST      R0,#0x10
   \   00001094   0C00000A           BEQ      ??uip_process_113
   1697          	uip_slen = 0;
   \   00001098   2C059FE5           LDR      R0,??uip_process_65+0x6C  ;; uip_slen
   \   0000109C   0010A0E3           MOV      R1,#+0
   \   000010A0   B010C0E1           STRH     R1,[R0, #+0]
   1698          	uip_connr->len = 1;
   \   000010A4   0100A0E3           MOV      R0,#+1
   \   000010A8   B001C5E1           STRH     R0,[R5, #+16]
   1699          	uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
   \   000010AC   0400A0E3           MOV      R0,#+4
   \   000010B0   1900C5E5           STRB     R0,[R5, #+25]
   1700          	uip_connr->nrtx = 0;
   \   000010B4   0000A0E3           MOV      R0,#+0
   \   000010B8   1B00C5E5           STRB     R0,[R5, #+27]
   1701          	BUF->flags = TCP_FIN | TCP_ACK;
   \   000010BC   E4049FE5           LDR      R0,??uip_process_65+0x48  ;; uip_buf + 47
   \   000010C0   1110A0E3           MOV      R1,#+17
   \   000010C4   0010C0E5           STRB     R1,[R0, #+0]
   1702          	goto tcp_send_nodata;
   \   000010C8   9C0000EA           B        ??uip_process_21
   1703                }
   1704          
   1705                /* If uip_slen > 0, the application has data to be sent. */
   1706                if(uip_slen > 0) {
   \                     ??uip_process_113:
   \   000010CC   F8049FE5           LDR      R0,??uip_process_65+0x6C  ;; uip_slen
   \   000010D0   B000D0E1           LDRH     R0,[R0, #+0]
   \   000010D4   010050E3           CMP      R0,#+1
   \   000010D8   1700003A           BCC      ??uip_process_114
   1707          
   1708          	/* If the connection has acknowledged data, the contents of
   1709          	   the ->len variable should be discarded. */
   1710          	if((uip_flags & UIP_ACKDATA) != 0) {
   \   000010DC   D8049FE5           LDR      R0,??uip_process_65+0x5C  ;; uip_flags
   \   000010E0   0000D0E5           LDRB     R0,[R0, #+0]
   \   000010E4   010010E3           TST      R0,#0x1
   \   000010E8   0100000A           BEQ      ??uip_process_115
   1711          	  uip_connr->len = 0;
   \   000010EC   0000A0E3           MOV      R0,#+0
   \   000010F0   B001C5E1           STRH     R0,[R5, #+16]
   1712          	}
   1713          
   1714          	/* If the ->len variable is non-zero the connection has
   1715          	   already data in transit and cannot send anymore right
   1716          	   now. */
   1717          	if(uip_connr->len == 0) {
   \                     ??uip_process_115:
   \   000010F4   B001D5E1           LDRH     R0,[R5, #+16]
   \   000010F8   000050E3           CMP      R0,#+0
   \   000010FC   0B00001A           BNE      ??uip_process_116
   1718          
   1719          	  /* The application cannot send more than what is allowed by
   1720          	     the mss (the minumum of the MSS and the available
   1721          	     window). */
   1722          	  if(uip_slen > uip_connr->mss) {
   \   00001100   B201D5E1           LDRH     R0,[R5, #+18]
   \   00001104   C0149FE5           LDR      R1,??uip_process_65+0x6C  ;; uip_slen
   \   00001108   B010D1E1           LDRH     R1,[R1, #+0]
   \   0000110C   010050E1           CMP      R0,R1
   \   00001110   0000009A           BLS      ??uip_process_117
   \   00001114   0100B0E1           MOVS     R0,R1
   \                     ??uip_process_117:
   \   00001118   AC149FE5           LDR      R1,??uip_process_65+0x6C  ;; uip_slen
   \   0000111C   B000C1E1           STRH     R0,[R1, #+0]
   1723          	    uip_slen = uip_connr->mss;
   1724          	  }
   1725          
   1726          	  /* Remember how much data we send out now so that we know
   1727          	     when everything has been acknowledged. */
   1728          	  uip_connr->len = uip_slen;
   \   00001120   A4049FE5           LDR      R0,??uip_process_65+0x6C  ;; uip_slen
   \   00001124   B000D0E1           LDRH     R0,[R0, #+0]
   \   00001128   B001C5E1           STRH     R0,[R5, #+16]
   \   0000112C   020000EA           B        ??uip_process_118
   1729          	} else {
   1730          
   1731          	  /* If the application already had unacknowledged data, we
   1732          	     make sure that the application does not send (i.e.,
   1733          	     retransmit) out more than it previously sent out. */
   1734          	  uip_slen = uip_connr->len;
   \                     ??uip_process_116:
   \   00001130   B001D5E1           LDRH     R0,[R5, #+16]
   \   00001134   90149FE5           LDR      R1,??uip_process_65+0x6C  ;; uip_slen
   \   00001138   B000C1E1           STRH     R0,[R1, #+0]
   1735          	}
   1736                }
   1737                uip_connr->nrtx = 0;
   \                     ??uip_process_118:
   \                     ??uip_process_114:
   \   0000113C   0000A0E3           MOV      R0,#+0
   \   00001140   1B00C5E5           STRB     R0,[R5, #+27]
   1738              apprexmit:
   1739                uip_appdata = uip_sappdata;
   \                     ??uip_process_28:
   \   00001144   68049FE5           LDR      R0,??uip_process_65+0x54  ;; uip_appdata
   \   00001148   80149FE5           LDR      R1,??uip_process_65+0x70  ;; uip_sappdata
   \   0000114C   001091E5           LDR      R1,[R1, #+0]
   \   00001150   001080E5           STR      R1,[R0, #+0]
   1740          
   1741                /* If the application has data to be sent, or if the incoming
   1742                   packet had new data in it, we must send out a packet. */
   1743                if(uip_slen > 0 && uip_connr->len > 0) {
   \   00001154   70049FE5           LDR      R0,??uip_process_65+0x6C  ;; uip_slen
   \   00001158   B000D0E1           LDRH     R0,[R0, #+0]
   \   0000115C   010050E3           CMP      R0,#+1
   \   00001160   0A00003A           BCC      ??uip_process_119
   \   00001164   B001D5E1           LDRH     R0,[R5, #+16]
   \   00001168   010050E3           CMP      R0,#+1
   \   0000116C   0700003A           BCC      ??uip_process_119
   1744          	/* Add the length of the IP and TCP headers. */
   1745          	uip_len = uip_connr->len + UIP_TCPIP_HLEN;
   \   00001170   B001D5E1           LDRH     R0,[R5, #+16]
   \   00001174   280090E2           ADDS     R0,R0,#+40
   \   00001178   38149FE5           LDR      R1,??uip_process_65+0x58  ;; uip_len
   \   0000117C   B000C1E1           STRH     R0,[R1, #+0]
   1746          	/* We always set the ACK flag in response packets. */
   1747          	BUF->flags = TCP_ACK | TCP_PSH;
   \   00001180   20049FE5           LDR      R0,??uip_process_65+0x48  ;; uip_buf + 47
   \   00001184   1810A0E3           MOV      R1,#+24
   \   00001188   0010C0E5           STRB     R1,[R0, #+0]
   1748          	/* Send the packet. */
   1749          	goto tcp_send_noopts;
   \   0000118C   6E0000EA           B        ??uip_process_120
   1750                }
   1751                /* If there is no data to send, just send out a pure ACK if
   1752          	 there is newdata. */
   1753                if(uip_flags & UIP_NEWDATA) {
   \                     ??uip_process_119:
   \   00001190   24049FE5           LDR      R0,??uip_process_65+0x5C  ;; uip_flags
   \   00001194   0000D0E5           LDRB     R0,[R0, #+0]
   \   00001198   020010E3           TST      R0,#0x2
   \   0000119C   0600000A           BEQ      ??uip_process_121
   1754          	uip_len = UIP_TCPIP_HLEN;
   \   000011A0   10049FE5           LDR      R0,??uip_process_65+0x58  ;; uip_len
   \   000011A4   2810A0E3           MOV      R1,#+40
   \   000011A8   B010C0E1           STRH     R1,[R0, #+0]
   1755          	BUF->flags = TCP_ACK;
   \   000011AC   F4039FE5           LDR      R0,??uip_process_65+0x48  ;; uip_buf + 47
   \   000011B0   1010A0E3           MOV      R1,#+16
   \   000011B4   0010C0E5           STRB     R1,[R0, #+0]
   1756          	goto tcp_send_noopts;
   \   000011B8   630000EA           B        ??uip_process_120
   1757                }
   1758              }
   1759              goto drop;
   \                     ??uip_process_121:
   \                     ??uip_process_111:
   \   000011BC   DF0000EA           B        ??uip_process_6
   1760            case UIP_LAST_ACK:
   1761              /* We can close this connection if the peer has acknowledged our
   1762                 FIN. This is indicated by the UIP_ACKDATA flag. */
   1763              if(uip_flags & UIP_ACKDATA) {
   \                     ??uip_process_122:
   \   000011C0   F4039FE5           LDR      R0,??uip_process_65+0x5C  ;; uip_flags
   \   000011C4   0000D0E5           LDRB     R0,[R0, #+0]
   \   000011C8   010010E3           TST      R0,#0x1
   \   000011CC   0500000A           BEQ      ??uip_process_123
   1764                uip_connr->tcpstateflags = UIP_CLOSED;
   \   000011D0   0000A0E3           MOV      R0,#+0
   \   000011D4   1900C5E5           STRB     R0,[R5, #+25]
   1765                uip_flags = UIP_CLOSE;
   \   000011D8   DC039FE5           LDR      R0,??uip_process_65+0x5C  ;; uip_flags
   \   000011DC   1010A0E3           MOV      R1,#+16
   \   000011E0   0010C0E5           STRB     R1,[R0, #+0]
   1766                UIP_APPCALL();
   \   000011E4   ........           BL       telnetd_appcall
   \                     ??uip_process_123:
   \   000011E8   500000EA           B        ??uip_process_124
   1767              }
   1768              break;
   1769          
   1770            case UIP_FIN_WAIT_1:
   1771              /* The application has closed the connection, but the remote host
   1772                 hasn't closed its end yet. Thus we do nothing but wait for a
   1773                 FIN from the other side. */
   1774              if(uip_len > 0) {
   \                     ??uip_process_125:
   \   000011EC   C4039FE5           LDR      R0,??uip_process_65+0x58  ;; uip_len
   \   000011F0   B000D0E1           LDRH     R0,[R0, #+0]
   \   000011F4   010050E3           CMP      R0,#+1
   \   000011F8   0200003A           BCC      ??uip_process_126
   1775                uip_add_rcv_nxt(uip_len);
   \   000011FC   B4039FE5           LDR      R0,??uip_process_65+0x58  ;; uip_len
   \   00001200   B000D0E1           LDRH     R0,[R0, #+0]
   \   00001204   ........           BL       uip_add_rcv_nxt
   1776              }
   1777              if(BUF->flags & TCP_FIN) {
   \                     ??uip_process_126:
   \   00001208   98039FE5           LDR      R0,??uip_process_65+0x48  ;; uip_buf + 47
   \   0000120C   0000D0E5           LDRB     R0,[R0, #+0]
   \   00001210   010010E3           TST      R0,#0x1
   \   00001214   1300000A           BEQ      ??uip_process_127
   1778                if(uip_flags & UIP_ACKDATA) {
   \   00001218   9C039FE5           LDR      R0,??uip_process_65+0x5C  ;; uip_flags
   \   0000121C   0000D0E5           LDRB     R0,[R0, #+0]
   \   00001220   010010E3           TST      R0,#0x1
   \   00001224   0600000A           BEQ      ??uip_process_128
   1779          	uip_connr->tcpstateflags = UIP_TIME_WAIT;
   \   00001228   0700A0E3           MOV      R0,#+7
   \   0000122C   1900C5E5           STRB     R0,[R5, #+25]
   1780          	uip_connr->timer = 0;
   \   00001230   0000A0E3           MOV      R0,#+0
   \   00001234   1A00C5E5           STRB     R0,[R5, #+26]
   1781          	uip_connr->len = 0;
   \   00001238   0000A0E3           MOV      R0,#+0
   \   0000123C   B001C5E1           STRH     R0,[R5, #+16]
   \   00001240   010000EA           B        ??uip_process_129
   1782                } else {
   1783          	uip_connr->tcpstateflags = UIP_CLOSING;
   \                     ??uip_process_128:
   \   00001244   0600A0E3           MOV      R0,#+6
   \   00001248   1900C5E5           STRB     R0,[R5, #+25]
   1784                }
   1785                uip_add_rcv_nxt(1);
   \                     ??uip_process_129:
   \   0000124C   0100A0E3           MOV      R0,#+1
   \   00001250   ........           BL       uip_add_rcv_nxt
   1786                uip_flags = UIP_CLOSE;
   \   00001254   60039FE5           LDR      R0,??uip_process_65+0x5C  ;; uip_flags
   \   00001258   1010A0E3           MOV      R1,#+16
   \   0000125C   0010C0E5           STRB     R1,[R0, #+0]
   1787                UIP_APPCALL();
   \   00001260   ........           BL       telnetd_appcall
   1788                goto tcp_send_ack;
   \   00001264   320000EA           B        ??uip_process_94
   1789              } else if(uip_flags & UIP_ACKDATA) {
   \                     ??uip_process_127:
   \   00001268   4C039FE5           LDR      R0,??uip_process_65+0x5C  ;; uip_flags
   \   0000126C   0000D0E5           LDRB     R0,[R0, #+0]
   \   00001270   010010E3           TST      R0,#0x1
   \   00001274   0400000A           BEQ      ??uip_process_130
   1790                uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
   \   00001278   0500A0E3           MOV      R0,#+5
   \   0000127C   1900C5E5           STRB     R0,[R5, #+25]
   1791                uip_connr->len = 0;
   \   00001280   0000A0E3           MOV      R0,#+0
   \   00001284   B001C5E1           STRH     R0,[R5, #+16]
   1792                goto drop;
   \   00001288   AC0000EA           B        ??uip_process_6
   1793              }
   1794              if(uip_len > 0) {
   \                     ??uip_process_130:
   \   0000128C   24039FE5           LDR      R0,??uip_process_65+0x58  ;; uip_len
   \   00001290   B000D0E1           LDRH     R0,[R0, #+0]
   \   00001294   010050E3           CMP      R0,#+1
   \   00001298   2500002A           BCS      ??uip_process_94
   1795                goto tcp_send_ack;
   1796              }
   1797              goto drop;
   \                     ??uip_process_131:
   \   0000129C   A70000EA           B        ??uip_process_6
   1798          
   1799            case UIP_FIN_WAIT_2:
   1800              if(uip_len > 0) {
   \                     ??uip_process_132:
   \   000012A0   10039FE5           LDR      R0,??uip_process_65+0x58  ;; uip_len
   \   000012A4   B000D0E1           LDRH     R0,[R0, #+0]
   \   000012A8   010050E3           CMP      R0,#+1
   \   000012AC   0200003A           BCC      ??uip_process_133
   1801                uip_add_rcv_nxt(uip_len);
   \   000012B0   00039FE5           LDR      R0,??uip_process_65+0x58  ;; uip_len
   \   000012B4   B000D0E1           LDRH     R0,[R0, #+0]
   \   000012B8   ........           BL       uip_add_rcv_nxt
   1802              }
   1803              if(BUF->flags & TCP_FIN) {
   \                     ??uip_process_133:
   \   000012BC   E4029FE5           LDR      R0,??uip_process_65+0x48  ;; uip_buf + 47
   \   000012C0   0000D0E5           LDRB     R0,[R0, #+0]
   \   000012C4   010010E3           TST      R0,#0x1
   \   000012C8   0A00000A           BEQ      ??uip_process_134
   1804                uip_connr->tcpstateflags = UIP_TIME_WAIT;
   \   000012CC   0700A0E3           MOV      R0,#+7
   \   000012D0   1900C5E5           STRB     R0,[R5, #+25]
   1805                uip_connr->timer = 0;
   \   000012D4   0000A0E3           MOV      R0,#+0
   \   000012D8   1A00C5E5           STRB     R0,[R5, #+26]
   1806                uip_add_rcv_nxt(1);
   \   000012DC   0100A0E3           MOV      R0,#+1
   \   000012E0   ........           BL       uip_add_rcv_nxt
   1807                uip_flags = UIP_CLOSE;
   \   000012E4   D0029FE5           LDR      R0,??uip_process_65+0x5C  ;; uip_flags
   \   000012E8   1010A0E3           MOV      R1,#+16
   \   000012EC   0010C0E5           STRB     R1,[R0, #+0]
   1808                UIP_APPCALL();
   \   000012F0   ........           BL       telnetd_appcall
   1809                goto tcp_send_ack;
   \   000012F4   0E0000EA           B        ??uip_process_94
   1810              }
   1811              if(uip_len > 0) {
   \                     ??uip_process_134:
   \   000012F8   B8029FE5           LDR      R0,??uip_process_65+0x58  ;; uip_len
   \   000012FC   B000D0E1           LDRH     R0,[R0, #+0]
   \   00001300   010050E3           CMP      R0,#+1
   \   00001304   0A00002A           BCS      ??uip_process_94
   1812                goto tcp_send_ack;
   1813              }
   1814              goto drop;
   \                     ??uip_process_135:
   \   00001308   8C0000EA           B        ??uip_process_6
   1815          
   1816            case UIP_TIME_WAIT:
   1817              goto tcp_send_ack;
   \                     ??uip_process_136:
   \   0000130C   080000EA           B        ??uip_process_94
   1818          
   1819            case UIP_CLOSING:
   1820              if(uip_flags & UIP_ACKDATA) {
   \                     ??uip_process_137:
   \   00001310   A4029FE5           LDR      R0,??uip_process_65+0x5C  ;; uip_flags
   \   00001314   0000D0E5           LDRB     R0,[R0, #+0]
   \   00001318   010010E3           TST      R0,#0x1
   \   0000131C   0300000A           BEQ      ??uip_process_138
   1821                uip_connr->tcpstateflags = UIP_TIME_WAIT;
   \   00001320   0700A0E3           MOV      R0,#+7
   \   00001324   1900C5E5           STRB     R0,[R5, #+25]
   1822                uip_connr->timer = 0;
   \   00001328   0000A0E3           MOV      R0,#+0
   \   0000132C   1A00C5E5           STRB     R0,[R5, #+26]
   1823              }
   1824            }
   1825            goto drop;
   \                     ??uip_process_138:
   \                     ??uip_process_124:
   \                     ??uip_process_99:
   \   00001330   820000EA           B        ??uip_process_6
   1826          
   1827          
   1828            /* We jump here when we are ready to send the packet, and just want
   1829               to set the appropriate TCP sequence numbers in the TCP header. */
   1830           tcp_send_ack:
   1831            BUF->flags = TCP_ACK;
   \                     ??uip_process_94:
   \   00001334   6C029FE5           LDR      R0,??uip_process_65+0x48  ;; uip_buf + 47
   \   00001338   1010A0E3           MOV      R1,#+16
   \   0000133C   0010C0E5           STRB     R1,[R0, #+0]
   1832           tcp_send_nodata:
   1833            uip_len = UIP_IPTCPH_LEN;
   \                     ??uip_process_21:
   \   00001340   70029FE5           LDR      R0,??uip_process_65+0x58  ;; uip_len
   \   00001344   2810A0E3           MOV      R1,#+40
   \   00001348   B010C0E1           STRH     R1,[R0, #+0]
   1834           tcp_send_noopts:
   1835            BUF->tcpoffset = (UIP_TCPH_LEN / 4) << 4;
   \                     ??uip_process_120:
   \   0000134C   0C029FE5           LDR      R0,??uip_process_65  ;; uip_buf + 46
   \   00001350   5010A0E3           MOV      R1,#+80
   \   00001354   0010C0E5           STRB     R1,[R0, #+0]
   1836           tcp_send:
   1837            /* We're done with the input processing. We are now ready to send a
   1838               reply. Our job is to fill in all the fields of the TCP and IP
   1839               headers before calculating the checksum and finally send the
   1840               packet. */
   1841            BUF->ackno[0] = uip_connr->rcv_nxt[0];
   \                     ??uip_process_88:
   \   00001358   20029FE5           LDR      R0,??uip_process_65+0x20  ;; uip_buf + 42
   \   0000135C   0810D5E5           LDRB     R1,[R5, #+8]
   \   00001360   0010C0E5           STRB     R1,[R0, #+0]
   1842            BUF->ackno[1] = uip_connr->rcv_nxt[1];
   \   00001364   0C029FE5           LDR      R0,??uip_process_65+0x18  ;; uip_buf + 43
   \   00001368   0910D5E5           LDRB     R1,[R5, #+9]
   \   0000136C   0010C0E5           STRB     R1,[R0, #+0]
   1843            BUF->ackno[2] = uip_connr->rcv_nxt[2];
   \   00001370   F8019FE5           LDR      R0,??uip_process_65+0x10  ;; uip_buf + 44
   \   00001374   0A10D5E5           LDRB     R1,[R5, #+10]
   \   00001378   0010C0E5           STRB     R1,[R0, #+0]
   1844            BUF->ackno[3] = uip_connr->rcv_nxt[3];
   \   0000137C   E4019FE5           LDR      R0,??uip_process_65+0x8  ;; uip_buf + 45
   \   00001380   0B10D5E5           LDRB     R1,[R5, #+11]
   \   00001384   0010C0E5           STRB     R1,[R0, #+0]
   1845          
   1846            BUF->seqno[0] = uip_connr->snd_nxt[0];
   \   00001388   EC019FE5           LDR      R0,??uip_process_65+0x1C  ;; uip_buf + 38
   \   0000138C   0C10D5E5           LDRB     R1,[R5, #+12]
   \   00001390   0010C0E5           STRB     R1,[R0, #+0]
   1847            BUF->seqno[1] = uip_connr->snd_nxt[1];
   \   00001394   D8019FE5           LDR      R0,??uip_process_65+0x14  ;; uip_buf + 39
   \   00001398   0D10D5E5           LDRB     R1,[R5, #+13]
   \   0000139C   0010C0E5           STRB     R1,[R0, #+0]
   1848            BUF->seqno[2] = uip_connr->snd_nxt[2];
   \   000013A0   C4019FE5           LDR      R0,??uip_process_65+0xC  ;; uip_buf + 40
   \   000013A4   0E10D5E5           LDRB     R1,[R5, #+14]
   \   000013A8   0010C0E5           STRB     R1,[R0, #+0]
   1849            BUF->seqno[3] = uip_connr->snd_nxt[3];
   \   000013AC   B0019FE5           LDR      R0,??uip_process_65+0x4  ;; uip_buf + 41
   \   000013B0   0F10D5E5           LDRB     R1,[R5, #+15]
   \   000013B4   0010C0E5           STRB     R1,[R0, #+0]
   1850          
   1851            BUF->proto = UIP_PROTO_TCP;
   \   000013B8   14029FE5           LDR      R0,??uip_process_65+0x74  ;; uip_buf + 23
   \   000013BC   0610A0E3           MOV      R1,#+6
   \   000013C0   0010C0E5           STRB     R1,[R0, #+0]
   1852          
   1853            BUF->srcport  = uip_connr->lport;
   \   000013C4   0C029FE5           LDR      R0,??uip_process_65+0x78  ;; uip_buf + 34
   \   000013C8   B410D5E1           LDRH     R1,[R5, #+4]
   \   000013CC   B010C0E1           STRH     R1,[R0, #+0]
   1854            BUF->destport = uip_connr->rport;
   \   000013D0   04029FE5           LDR      R0,??uip_process_65+0x7C  ;; uip_buf + 36
   \   000013D4   B610D5E1           LDRH     R1,[R5, #+6]
   \   000013D8   B010C0E1           STRH     R1,[R0, #+0]
   1855          
   1856            uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
   \   000013DC   FC019FE5           LDR      R0,??uip_process_65+0x80  ;; uip_buf + 26
   \   000013E0   FC119FE5           LDR      R1,??uip_process_65+0x84  ;; uip_hostaddr
   \   000013E4   B010D1E1           LDRH     R1,[R1, #+0]
   \   000013E8   B010C0E1           STRH     R1,[R0, #+0]
   \   000013EC   F4019FE5           LDR      R0,??uip_process_65+0x88  ;; uip_buf + 28
   \   000013F0   F4119FE5           LDR      R1,??uip_process_65+0x8C  ;; uip_hostaddr + 2
   \   000013F4   B010D1E1           LDRH     R1,[R1, #+0]
   \   000013F8   B010C0E1           STRH     R1,[R0, #+0]
   1857            uip_ipaddr_copy(BUF->destipaddr, uip_connr->ripaddr);
   \   000013FC   EC019FE5           LDR      R0,??uip_process_65+0x90  ;; uip_buf + 30
   \   00001400   B010D5E1           LDRH     R1,[R5, #+0]
   \   00001404   B010C0E1           STRH     R1,[R0, #+0]
   \   00001408   E4019FE5           LDR      R0,??uip_process_65+0x94  ;; uip_buf + 32
   \   0000140C   B210D5E1           LDRH     R1,[R5, #+2]
   \   00001410   B010C0E1           STRH     R1,[R0, #+0]
   1858          
   1859            if(uip_connr->tcpstateflags & UIP_STOPPED) {
   \   00001414   1900D5E5           LDRB     R0,[R5, #+25]
   \   00001418   100010E3           TST      R0,#0x10
   \   0000141C   0500000A           BEQ      ??uip_process_139
   1860              /* If the connection has issued uip_stop(), we advertise a zero
   1861                 window so that the remote host will stop sending data. */
   1862              BUF->wnd[0] = BUF->wnd[1] = 0;
   \   00001420   0000A0E3           MOV      R0,#+0
   \   00001424   98119FE5           LDR      R1,??uip_process_65+0x64  ;; uip_buf + 49
   \   00001428   0000C1E5           STRB     R0,[R1, #+0]
   \   0000142C   8C119FE5           LDR      R1,??uip_process_65+0x60  ;; uip_buf + 48
   \   00001430   0000C1E5           STRB     R0,[R1, #+0]
   \   00001434   050000EA           B        ??uip_process_140
   1863            } else {
   1864              BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
   \                     ??uip_process_139:
   \   00001438   80019FE5           LDR      R0,??uip_process_65+0x60  ;; uip_buf + 48
   \   0000143C   0510A0E3           MOV      R1,#+5
   \   00001440   0010C0E5           STRB     R1,[R0, #+0]
   1865              BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff);
   \   00001444   78019FE5           LDR      R0,??uip_process_65+0x64  ;; uip_buf + 49
   \   00001448   A610A0E3           MOV      R1,#+166
   \   0000144C   0010C0E5           STRB     R1,[R0, #+0]
   1866            }
   1867          
   1868           tcp_send_noconn:
   1869            BUF->ttl = UIP_TTL;
   \                     ??uip_process_140:
   \                     ??uip_process_69:
   \   00001450   A0019FE5           LDR      R0,??uip_process_65+0x98  ;; uip_buf + 22
   \   00001454   4010A0E3           MOV      R1,#+64
   \   00001458   0010C0E5           STRB     R1,[R0, #+0]
   1870          //#if UIP_CONF_IPV6
   1871          //  /* For IPv6, the IP length field does not include the IPv6 IP header
   1872          //     length. */
   1873          //  BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
   1874          //  BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
   1875          //#else /* UIP_CONF_IPV6 */
   1876            BUF->len[0] = (uip_len >> 8);
   \   0000145C   98019FE5           LDR      R0,??uip_process_65+0x9C  ;; uip_buf + 16
   \   00001460   50119FE5           LDR      R1,??uip_process_65+0x58  ;; uip_len
   \   00001464   B010D1E1           LDRH     R1,[R1, #+0]
   \   00001468   2114B0E1           LSRS     R1,R1,#+8
   \   0000146C   0010C0E5           STRB     R1,[R0, #+0]
   1877            BUF->len[1] = (uip_len & 0xff);
   \   00001470   88019FE5           LDR      R0,??uip_process_65+0xA0  ;; uip_buf + 17
   \   00001474   3C119FE5           LDR      R1,??uip_process_65+0x58  ;; uip_len
   \   00001478   B010D1E1           LDRH     R1,[R1, #+0]
   \   0000147C   0010C0E5           STRB     R1,[R0, #+0]
   1878          //#endif /* UIP_CONF_IPV6 */
   1879          
   1880            BUF->urgp[0] = BUF->urgp[1] = 0;
   \   00001480   0000A0E3           MOV      R0,#+0
   \   00001484   24119FE5           LDR      R1,??uip_process_65+0x50  ;; uip_buf + 53
   \   00001488   0000C1E5           STRB     R0,[R1, #+0]
   \   0000148C   18119FE5           LDR      R1,??uip_process_65+0x4C  ;; uip_buf + 52
   \   00001490   0000C1E5           STRB     R0,[R1, #+0]
   1881          
   1882            /* Calculate TCP checksum. */
   1883            BUF->tcpchksum = 0;
   \   00001494   68019FE5           LDR      R0,??uip_process_65+0xA4  ;; uip_buf + 50
   \   00001498   0010A0E3           MOV      R1,#+0
   \   0000149C   B010C0E1           STRH     R1,[R0, #+0]
   1884            BUF->tcpchksum = ~(uip_tcpchksum());
   \   000014A0   ........           BL       uip_tcpchksum
   \   000014A4   0000F0E1           MVNS     R0,R0
   \   000014A8   54119FE5           LDR      R1,??uip_process_65+0xA4  ;; uip_buf + 50
   \   000014AC   B000C1E1           STRH     R0,[R1, #+0]
   1885          
   1886          //#if UIP_UDP  
   1887          // ip_send_nolen:
   1888          //#endif /* UIP_UDP */
   1889           
   1890          //#if UIP_CONF_IPV6
   1891          //  BUF->vtc = 0x60;
   1892          //  BUF->tcflow = 0x00;
   1893          //  BUF->flow = 0x00;
   1894          //#else /* UIP_CONF_IPV6 */
   1895            BUF->vhl = 0x45;
   \   000014B0   50019FE5           LDR      R0,??uip_process_65+0xA8  ;; uip_buf + 14
   \   000014B4   4510A0E3           MOV      R1,#+69
   \   000014B8   0010C0E5           STRB     R1,[R0, #+0]
   1896            BUF->tos = 0;
   \   000014BC   48019FE5           LDR      R0,??uip_process_65+0xAC  ;; uip_buf + 15
   \   000014C0   0010A0E3           MOV      R1,#+0
   \   000014C4   0010C0E5           STRB     R1,[R0, #+0]
   1897            BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
   \   000014C8   0000A0E3           MOV      R0,#+0
   \   000014CC   3C119FE5           LDR      R1,??uip_process_65+0xB0  ;; uip_buf + 21
   \   000014D0   0000C1E5           STRB     R0,[R1, #+0]
   \   000014D4   38119FE5           LDR      R1,??uip_process_65+0xB4  ;; uip_buf + 20
   \   000014D8   0000C1E5           STRB     R0,[R1, #+0]
   1898            ++ipid;
   \   000014DC   34019FE5           LDR      R0,??uip_process_65+0xB8  ;; ipid
   \   000014E0   B000D0E1           LDRH     R0,[R0, #+0]
   \   000014E4   010090E2           ADDS     R0,R0,#+1
   \   000014E8   28119FE5           LDR      R1,??uip_process_65+0xB8  ;; ipid
   \   000014EC   B000C1E1           STRH     R0,[R1, #+0]
   1899            BUF->ipid[0] = ipid >> 8;
   \   000014F0   24019FE5           LDR      R0,??uip_process_65+0xBC  ;; uip_buf + 18
   \   000014F4   1C119FE5           LDR      R1,??uip_process_65+0xB8  ;; ipid
   \   000014F8   B010D1E1           LDRH     R1,[R1, #+0]
   \   000014FC   2114B0E1           LSRS     R1,R1,#+8
   \   00001500   0010C0E5           STRB     R1,[R0, #+0]
   1900            BUF->ipid[1] = ipid & 0xff;
   \   00001504   14019FE5           LDR      R0,??uip_process_65+0xC0  ;; uip_buf + 19
   \   00001508   08119FE5           LDR      R1,??uip_process_65+0xB8  ;; ipid
   \   0000150C   B010D1E1           LDRH     R1,[R1, #+0]
   \   00001510   0010C0E5           STRB     R1,[R0, #+0]
   1901            /* Calculate IP checksum. */
   1902            BUF->ipchksum = 0;
   \   00001514   08019FE5           LDR      R0,??uip_process_65+0xC4  ;; uip_buf + 24
   \   00001518   0010A0E3           MOV      R1,#+0
   \   0000151C   B010C0E1           STRH     R1,[R0, #+0]
   1903            BUF->ipchksum = ~(uip_ipchksum());
   \   00001520   ........           BL       uip_ipchksum
   \   00001524   0000F0E1           MVNS     R0,R0
   \   00001528   F4109FE5           LDR      R1,??uip_process_65+0xC4  ;; uip_buf + 24
   \   0000152C   B000C1E1           STRH     R0,[R1, #+0]
   1904            DEBUG_PRINTF("uip ip_send_nolen: chkecum 0x%04x\n", uip_ipchksum());
   1905          //#endif /* UIP_CONF_IPV6 */
   1906          
   1907            UIP_STAT(++uip_stat.tcp.sent);
   1908           send:
   1909            DEBUG_PRINTF("Sending packet with length %d (%d)\n", uip_len,
   1910          	       (BUF->len[0] << 8) | BUF->len[1]);
   1911          
   1912            UIP_STAT(++uip_stat.ip.sent);
   1913            /* Return and let the caller do the actual transmission. */
   1914            uip_flags = 0;
   \                     ??uip_process_52:
   \   00001530   84009FE5           LDR      R0,??uip_process_65+0x5C  ;; uip_flags
   \   00001534   0010A0E3           MOV      R1,#+0
   \   00001538   0010C0E5           STRB     R1,[R0, #+0]
   1915            return;
   \   0000153C   050000EA           B        ??uip_process_48
   1916           drop:
   1917            uip_len = 0;
   \                     ??uip_process_6:
   \   00001540   70009FE5           LDR      R0,??uip_process_65+0x58  ;; uip_len
   \   00001544   0010A0E3           MOV      R1,#+0
   \   00001548   B010C0E1           STRH     R1,[R0, #+0]
   1918            uip_flags = 0;
   \   0000154C   68009FE5           LDR      R0,??uip_process_65+0x5C  ;; uip_flags
   \   00001550   0010A0E3           MOV      R1,#+0
   \   00001554   0010C0E5           STRB     R1,[R0, #+0]
   1919            return;
   \                     ??uip_process_48:
   \   00001558   3140BDE8           POP      {R0,R4,R5,LR}
   \   0000155C   1EFF2FE1           BX       LR               ;; return
   \                     ??uip_process_65:
   \   00001560   ........           DC32     uip_buf + 46
   \   00001564   ........           DC32     uip_buf + 41
   \   00001568   ........           DC32     uip_buf + 45
   \   0000156C   ........           DC32     uip_buf + 40
   \   00001570   ........           DC32     uip_buf + 44
   \   00001574   ........           DC32     uip_buf + 39
   \   00001578   ........           DC32     uip_buf + 43
   \   0000157C   ........           DC32     uip_buf + 38
   \   00001580   ........           DC32     uip_buf + 42
   \   00001584   ........           DC32     uip_buf
   \   00001588   ........           DC32     opt
   \   0000158C   ........           DC32     uip_buf + 55
   \   00001590   ........           DC32     uip_buf + 56
   \   00001594   ........           DC32     uip_buf + 57
   \   00001598   ........           DC32     uip_acc32
   \   0000159C   ........           DC32     uip_acc32 + 1
   \   000015A0   ........           DC32     uip_acc32 + 2
   \   000015A4   ........           DC32     uip_acc32 + 3
   \   000015A8   ........           DC32     uip_buf + 47
   \   000015AC   ........           DC32     uip_buf + 52
   \   000015B0   ........           DC32     uip_buf + 53
   \   000015B4   ........           DC32     uip_appdata
   \   000015B8   ........           DC32     uip_len
   \   000015BC   ........           DC32     uip_flags
   \   000015C0   ........           DC32     uip_buf + 48
   \   000015C4   ........           DC32     uip_buf + 49
   \   000015C8   ........           DC32     tmp16
   \   000015CC   ........           DC32     uip_slen
   \   000015D0   ........           DC32     uip_sappdata
   \   000015D4   ........           DC32     uip_buf + 23
   \   000015D8   ........           DC32     uip_buf + 34
   \   000015DC   ........           DC32     uip_buf + 36
   \   000015E0   ........           DC32     uip_buf + 26
   \   000015E4   ........           DC32     uip_hostaddr
   \   000015E8   ........           DC32     uip_buf + 28
   \   000015EC   ........           DC32     uip_hostaddr + 2
   \   000015F0   ........           DC32     uip_buf + 30
   \   000015F4   ........           DC32     uip_buf + 32
   \   000015F8   ........           DC32     uip_buf + 22
   \   000015FC   ........           DC32     uip_buf + 16
   \   00001600   ........           DC32     uip_buf + 17
   \   00001604   ........           DC32     uip_buf + 50
   \   00001608   ........           DC32     uip_buf + 14
   \   0000160C   ........           DC32     uip_buf + 15
   \   00001610   ........           DC32     uip_buf + 21
   \   00001614   ........           DC32     uip_buf + 20
   \   00001618   ........           DC32     ipid
   \   0000161C   ........           DC32     uip_buf + 18
   \   00001620   ........           DC32     uip_buf + 19
   \   00001624   ........           DC32     uip_buf + 24
   1920          }
   1921          /*---------------------------------------------------------------------------*/

   \                                 In section .text, align 4, keep-with-next
   1922          u16_t
   1923          htons(u16_t val)
   1924          {
   1925            return HTONS(val);
   \                     htons:
   \   00000000   0008A0E1           MOV      R0,R0, LSL #+16
   \   00000004   2008B0E1           MOVS     R0,R0, LSR #+16
   \   00000008   2014B0E1           LSRS     R1,R0,#+8
   \   0000000C   000491E1           ORRS     R0,R1,R0, LSL #+8
   \   00000010   0008A0E1           MOV      R0,R0, LSL #+16
   \   00000014   2008B0E1           MOVS     R0,R0, LSR #+16
   \   00000018   1EFF2FE1           BX       LR               ;; return
   1926          }
   1927          /*---------------------------------------------------------------------------*/

   \                                 In section .text, align 4, keep-with-next
   1928          void
   1929          uip_send(const void *data, int len)
   1930          {
   \                     uip_send:
   \   00000000   38402DE9           PUSH     {R3-R5,LR}
   \   00000004   0040B0E1           MOVS     R4,R0
   \   00000008   0150B0E1           MOVS     R5,R1
   1931            if(len > 0) {
   \   0000000C   010055E3           CMP      R5,#+1
   \   00000010   0B0000BA           BLT      ??uip_send_0
   1932              uip_slen = len;
   \   00000014   30009FE5           LDR      R0,??uip_send_1  ;; uip_slen
   \   00000018   B050C0E1           STRH     R5,[R0, #+0]
   1933              if(data != uip_sappdata) {
   \   0000001C   2C009FE5           LDR      R0,??uip_send_1+0x4  ;; uip_sappdata
   \   00000020   000090E5           LDR      R0,[R0, #+0]
   \   00000024   000054E1           CMP      R4,R0
   \   00000028   0500000A           BEQ      ??uip_send_2
   1934                memcpy(uip_sappdata, (data), uip_slen);
   \   0000002C   18009FE5           LDR      R0,??uip_send_1  ;; uip_slen
   \   00000030   B020D0E1           LDRH     R2,[R0, #+0]
   \   00000034   0410B0E1           MOVS     R1,R4
   \   00000038   10009FE5           LDR      R0,??uip_send_1+0x4  ;; uip_sappdata
   \   0000003C   000090E5           LDR      R0,[R0, #+0]
   \   00000040   ........           BL       memcpy
   1935              }
   1936            }
   1937          }
   \                     ??uip_send_2:
   \                     ??uip_send_0:
   \   00000044   3140BDE8           POP      {R0,R4,R5,LR}
   \   00000048   1EFF2FE1           BX       LR               ;; return
   \                     ??uip_send_1:
   \   0000004C   ........           DC32     uip_slen
   \   00000050   ........           DC32     uip_sappdata
   1938          //-----------------------------------------------------------------------------
   1939          extern void network_device_send(void);
   1940          //-----------------------------------------------------------------------------
   1941          typedef union myint
   1942          {
   1943          		  unsigned int data;
   1944                    struct
   1945          		  {
   1946          			 unsigned char  data2;
   1947          			 unsigned char  data1;
   1948                    };
   1949          } mint;
   1950          

   \                                 In section .text, align 4, keep-with-next
   1951          void uip_ping(u16_t *ipaddrdest,unsigned short ttl,unsigned short payload)
   1952          {
   \                     uip_ping:
   \   00000000   F8402DE9           PUSH     {R3-R7,LR}
   \   00000004   0050B0E1           MOVS     R5,R0
   \   00000008   0160B0E1           MOVS     R6,R1
   \   0000000C   0240B0E1           MOVS     R4,R2
   1953           int i = 0;
   \   00000010   0000A0E3           MOV      R0,#+0
   \   00000014   0070B0E1           MOVS     R7,R0
   1954           mint len_pak;
   1955           len_pak.data = 0;
   \   00000018   0010A0E3           MOV      R1,#+0
   \   0000001C   00108DE5           STR      R1,[SP, #+0]
   1956            //  ICMP  
   1957           ICMPBUF->vhl = 0x45; //  
   \   00000020   AC019FE5           LDR      R0,??uip_ping_0  ;; uip_buf + 14
   \   00000024   4510A0E3           MOV      R1,#+69
   \   00000028   0010C0E5           STRB     R1,[R0, #+0]
   1958           ICMPBUF->tos = 0x00;
   \   0000002C   A4019FE5           LDR      R0,??uip_ping_0+0x4  ;; uip_buf + 15
   \   00000030   0010A0E3           MOV      R1,#+0
   \   00000034   0010C0E5           STRB     R1,[R0, #+0]
   1959           len_pak.data = 28+payload;
   \   00000038   0410B0E1           MOVS     R1,R4
   \   0000003C   0118A0E1           MOV      R1,R1, LSL #+16
   \   00000040   2118B0E1           MOVS     R1,R1, LSR #+16
   \   00000044   1C1091E2           ADDS     R1,R1,#+28
   \   00000048   00108DE5           STR      R1,[SP, #+0]
   1960           ICMPBUF->len[0] = len_pak.data1;
   \   0000004C   88019FE5           LDR      R0,??uip_ping_0+0x8  ;; uip_buf + 16
   \   00000050   0110DDE5           LDRB     R1,[SP, #+1]
   \   00000054   0010C0E5           STRB     R1,[R0, #+0]
   1961           ICMPBUF->len[1] = len_pak.data2;
   \   00000058   80019FE5           LDR      R0,??uip_ping_0+0xC  ;; uip_buf + 17
   \   0000005C   0010DDE5           LDRB     R1,[SP, #+0]
   \   00000060   0010C0E5           STRB     R1,[R0, #+0]
   1962           ICMPBUF->ipid[0] = 0xF2;
   \   00000064   78019FE5           LDR      R0,??uip_ping_0+0x10  ;; uip_buf + 18
   \   00000068   F210A0E3           MOV      R1,#+242
   \   0000006C   0010C0E5           STRB     R1,[R0, #+0]
   1963           ICMPBUF->ipid[1] = 0x9C;
   \   00000070   70019FE5           LDR      R0,??uip_ping_0+0x14  ;; uip_buf + 19
   \   00000074   9C10A0E3           MOV      R1,#+156
   \   00000078   0010C0E5           STRB     R1,[R0, #+0]
   1964           ICMPBUF->ipoffset[0] = ICMPBUF->ipoffset[1] = 0;
   \   0000007C   0000A0E3           MOV      R0,#+0
   \   00000080   64119FE5           LDR      R1,??uip_ping_0+0x18  ;; uip_buf + 21
   \   00000084   0000C1E5           STRB     R0,[R1, #+0]
   \   00000088   60119FE5           LDR      R1,??uip_ping_0+0x1C  ;; uip_buf + 20
   \   0000008C   0000C1E5           STRB     R0,[R1, #+0]
   1965           ICMPBUF->ttl = ttl;
   \   00000090   5C019FE5           LDR      R0,??uip_ping_0+0x20  ;; uip_buf + 22
   \   00000094   0060C0E5           STRB     R6,[R0, #+0]
   1966           ICMPBUF->proto = UIP_PROTO_ICMP;
   \   00000098   58019FE5           LDR      R0,??uip_ping_0+0x24  ;; uip_buf + 23
   \   0000009C   0110A0E3           MOV      R1,#+1
   \   000000A0   0010C0E5           STRB     R1,[R0, #+0]
   1967           ICMPBUF->ipchksum = 0;
   \   000000A4   50019FE5           LDR      R0,??uip_ping_0+0x28  ;; uip_buf + 24
   \   000000A8   0010A0E3           MOV      R1,#+0
   \   000000AC   B010C0E1           STRH     R1,[R0, #+0]
   1968           uip_ipaddr_copy(BUF->destipaddr, ipaddrdest);
   \   000000B0   48019FE5           LDR      R0,??uip_ping_0+0x2C  ;; uip_buf + 30
   \   000000B4   B010D5E1           LDRH     R1,[R5, #+0]
   \   000000B8   B010C0E1           STRH     R1,[R0, #+0]
   \   000000BC   40019FE5           LDR      R0,??uip_ping_0+0x30  ;; uip_buf + 32
   \   000000C0   B210D5E1           LDRH     R1,[R5, #+2]
   \   000000C4   B010C0E1           STRH     R1,[R0, #+0]
   1969           uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
   \   000000C8   38019FE5           LDR      R0,??uip_ping_0+0x34  ;; uip_buf + 26
   \   000000CC   38119FE5           LDR      R1,??uip_ping_0+0x38  ;; uip_hostaddr
   \   000000D0   B010D1E1           LDRH     R1,[R1, #+0]
   \   000000D4   B010C0E1           STRH     R1,[R0, #+0]
   \   000000D8   30019FE5           LDR      R0,??uip_ping_0+0x3C  ;; uip_buf + 28
   \   000000DC   30119FE5           LDR      R1,??uip_ping_0+0x40  ;; uip_hostaddr + 2
   \   000000E0   B010D1E1           LDRH     R1,[R1, #+0]
   \   000000E4   B010C0E1           STRH     R1,[R0, #+0]
   1970          	/* ICMP (echo) header. */
   1971           ICMPBUF->type = 0x08;
   \   000000E8   28019FE5           LDR      R0,??uip_ping_0+0x44  ;; uip_buf + 34
   \   000000EC   0810A0E3           MOV      R1,#+8
   \   000000F0   0010C0E5           STRB     R1,[R0, #+0]
   1972           ICMPBUF->icode = 0x00;
   \   000000F4   20019FE5           LDR      R0,??uip_ping_0+0x48  ;; uip_buf + 35
   \   000000F8   0010A0E3           MOV      R1,#+0
   \   000000FC   0010C0E5           STRB     R1,[R0, #+0]
   1973           ICMPBUF->icmpchksum = 0x00;
   \   00000100   18019FE5           LDR      R0,??uip_ping_0+0x4C  ;; uip_buf + 36
   \   00000104   0010A0E3           MOV      R1,#+0
   \   00000108   B010C0E1           STRH     R1,[R0, #+0]
   1974           ICMPBUF->id = 0x0001;
   \   0000010C   10019FE5           LDR      R0,??uip_ping_0+0x50  ;; uip_buf + 38
   \   00000110   0110A0E3           MOV      R1,#+1
   \   00000114   B010C0E1           STRH     R1,[R0, #+0]
   1975           ICMPBUF->seqno = 0x034A;
   \   00000118   08019FE5           LDR      R0,??uip_ping_0+0x54  ;; uip_buf + 40
   \   0000011C   4A10A0E3           MOV      R1,#+74
   \   00000120   C01F81E3           ORR      R1,R1,#0x300
   \   00000124   B010C0E1           STRH     R1,[R0, #+0]
   1976           //uip_len = 73;//ICMPBUF->len[1];
   1977           for (i=0;i<payload;i++) uip_buf[42+i] = (0x61 +i);
   \   00000128   0000A0E3           MOV      R0,#+0
   \   0000012C   0070B0E1           MOVS     R7,R0
   \                     ??uip_ping_1:
   \   00000130   0400B0E1           MOVS     R0,R4
   \   00000134   0008A0E1           MOV      R0,R0, LSL #+16
   \   00000138   2008B0E1           MOVS     R0,R0, LSR #+16
   \   0000013C   000057E1           CMP      R7,R0
   \   00000140   060000AA           BGE      ??uip_ping_2
   \   00000144   E0009FE5           LDR      R0,??uip_ping_0+0x58  ;; uip_buf
   \   00000148   000097E0           ADDS     R0,R7,R0
   \   0000014C   0710B0E1           MOVS     R1,R7
   \   00000150   611091E2           ADDS     R1,R1,#+97
   \   00000154   2A10C0E5           STRB     R1,[R0, #+42]
   \   00000158   017097E2           ADDS     R7,R7,#+1
   \   0000015C   F3FFFFEA           B        ??uip_ping_1
   1978           ICMPBUF->icmpchksum = 0;
   \                     ??uip_ping_2:
   \   00000160   B8009FE5           LDR      R0,??uip_ping_0+0x4C  ;; uip_buf + 36
   \   00000164   0010A0E3           MOV      R1,#+0
   \   00000168   B010C0E1           STRH     R1,[R0, #+0]
   1979           //ICMPBUF->icmpchksum = ~uip_chksum((u16_t *)&(ICMPBUF->type), 8+payload);
   1980           ICMPBUF->icmpchksum = ~uip_chksum((u16_t *)&(ICMPBUF->type), 8+payload);
   \   0000016C   081094E2           ADDS     R1,R4,#+8
   \   00000170   0118A0E1           MOV      R1,R1, LSL #+16
   \   00000174   2118B0E1           MOVS     R1,R1, LSR #+16
   \   00000178   98009FE5           LDR      R0,??uip_ping_0+0x44  ;; uip_buf + 34
   \   0000017C   ........           BL       uip_chksum
   \   00000180   0000F0E1           MVNS     R0,R0
   \   00000184   94109FE5           LDR      R1,??uip_ping_0+0x4C  ;; uip_buf + 36
   \   00000188   B000C1E1           STRH     R0,[R1, #+0]
   1981            /* Calculate IP checksum. */
   1982           BUF->ipchksum = 0;
   \   0000018C   68009FE5           LDR      R0,??uip_ping_0+0x28  ;; uip_buf + 24
   \   00000190   0010A0E3           MOV      R1,#+0
   \   00000194   B010C0E1           STRH     R1,[R0, #+0]
   1983           BUF->ipchksum = ~(uip_ipchksum());
   \   00000198   ........           BL       uip_ipchksum
   \   0000019C   0000F0E1           MVNS     R0,R0
   \   000001A0   54109FE5           LDR      R1,??uip_ping_0+0x28  ;; uip_buf + 24
   \   000001A4   B000C1E1           STRH     R0,[R1, #+0]
   1984           uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
   \   000001A8   80009FE5           LDR      R0,??uip_ping_0+0x5C  ;; uip_appdata
   \   000001AC   80109FE5           LDR      R1,??uip_ping_0+0x60  ;; uip_buf + 54
   \   000001B0   001080E5           STR      R1,[R0, #+0]
   1985           ping_flag = 2;
   \   000001B4   7C009FE5           LDR      R0,??uip_ping_0+0x64  ;; ping_flag
   \   000001B8   0210A0E3           MOV      R1,#+2
   \   000001BC   0010C0E5           STRB     R1,[R0, #+0]
   1986           uip_len = 41+payload;//42+payload;//73;
   \   000001C0   290094E2           ADDS     R0,R4,#+41
   \   000001C4   70109FE5           LDR      R1,??uip_ping_0+0x68  ;; uip_len
   \   000001C8   B000C1E1           STRH     R0,[R1, #+0]
   1987          }
   \   000001CC   F140BDE8           POP      {R0,R4-R7,LR}
   \   000001D0   1EFF2FE1           BX       LR               ;; return
   \                     ??uip_ping_0:
   \   000001D4   ........           DC32     uip_buf + 14
   \   000001D8   ........           DC32     uip_buf + 15
   \   000001DC   ........           DC32     uip_buf + 16
   \   000001E0   ........           DC32     uip_buf + 17
   \   000001E4   ........           DC32     uip_buf + 18
   \   000001E8   ........           DC32     uip_buf + 19
   \   000001EC   ........           DC32     uip_buf + 21
   \   000001F0   ........           DC32     uip_buf + 20
   \   000001F4   ........           DC32     uip_buf + 22
   \   000001F8   ........           DC32     uip_buf + 23
   \   000001FC   ........           DC32     uip_buf + 24
   \   00000200   ........           DC32     uip_buf + 30
   \   00000204   ........           DC32     uip_buf + 32
   \   00000208   ........           DC32     uip_buf + 26
   \   0000020C   ........           DC32     uip_hostaddr
   \   00000210   ........           DC32     uip_buf + 28
   \   00000214   ........           DC32     uip_hostaddr + 2
   \   00000218   ........           DC32     uip_buf + 34
   \   0000021C   ........           DC32     uip_buf + 35
   \   00000220   ........           DC32     uip_buf + 36
   \   00000224   ........           DC32     uip_buf + 38
   \   00000228   ........           DC32     uip_buf + 40
   \   0000022C   ........           DC32     uip_buf
   \   00000230   ........           DC32     uip_appdata
   \   00000234   ........           DC32     uip_buf + 54
   \   00000238   ........           DC32     ping_flag
   \   0000023C   ........           DC32     uip_len

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   ........           DC32     ipid

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   ........           DC32     uip_buf + 14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   ........           DC32     uip_buf + 16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   ........           DC32     uip_buf + 17

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   ........           DC32     uip_buf + 26

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   ........           DC32     uip_buf + 34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34:
   \   00000000   ........           DC32     uip_conns

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50:
   \   00000000   ........           DC32     uip_listenports

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable52:
   \   00000000   ........           DC32     c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55:
   \   00000000   ........           DC32     uip_acc32

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57:
   \   00000000   ........           DC32     uip_acc32 + 1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59:
   \   00000000   ........           DC32     uip_acc32 + 2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable60:
   \   00000000   ........           DC32     uip_conn

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable61:
   \   00000000   ........           DC32     uip_acc32 + 3

   Maximum stack usage in bytes:

     Function           .cstack
     --------           -------
     chksum                 16
     htons                   0
     memcpy                 16
     uip_add32               0
     uip_add_rcv_nxt         8
     uip_chksum             16
     uip_init                0
     uip_ipchksum            8
     uip_listen              0
     uip_ping               24
     uip_process            16
     uip_send               16
     uip_setipid             0
     uip_tcpchksum           8
     uip_unlisten            0
     upper_layer_chksum     16


   Section sizes:

     Function/Label     Bytes
     --------------     -----
     memcpy               44
     uip_hostaddr          4
     uip_draddr            4
     uip_netmask           4
     all_zeroes_addr       4
     uip_ethaddr           8
     uip_buf            1504
     uip_appdata           4
     uip_sappdata          4
     uip_len               2
     uip_slen              2
     uip_flags             1
     uip_conn              4
     uip_conns           168
     uip_listenports       2
     ping_flag             1
     ipid                  2
     uip_setipid          12
     iss                   4
     uip_acc32             4
     c                     1
     opt                   1
     tmp16                 2
     uip_add32           268
     chksum              164
     uip_chksum           56
     uip_ipchksum         84
     upper_layer_chksum  176
     uip_tcpchksum        20
     uip_init            164
     uip_unlisten        128
     uip_listen          116
     uip_add_rcv_nxt     124
     uip_process        5672
     htons                28
     uip_send             84
     uip_ping            576
     ??DataTable0          4
     ??DataTable20         4
     ??DataTable21         4
     ??DataTable22         4
     ??DataTable23         4
     ??DataTable24         4
     ??DataTable34         4
     ??DataTable50         4
     ??DataTable52         4
     ??DataTable55         4
     ??DataTable57         4
     ??DataTable59         4
     ??DataTable60         4
     ??DataTable61         4

 
 1 726 bytes in section .bss
     4 bytes in section .rodata
 7 772 bytes in section .text
 
 7 728 bytes of CODE  memory (+ 44 bytes shared)
     4 bytes of CONST memory
 1 726 bytes of DATA  memory

Errors: none
Warnings: none
